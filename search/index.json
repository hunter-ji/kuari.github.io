[{"content":"前言 设想一个场景：\n你作为一个程序员，听着攒劲的小曲，写着优雅的代码，加班加点终于写完了迭代中分配的模块需求。然后你跟别的同事一联调，却发现各种问题。\n你跟同事A说：“你得在这种情况下给我数据A。“\n同事A一脸懵逼：“这种情况需求也没写啊，在这种情况下我也没有数据A啊！“\n然后你和同事A一起顺着业务流程，找到了负责上层模块的同事B。\n同事B一脸懵逼：“这个迭代中我没有这个模块的开发需求啊，这种情况下我也没有数据A啊！”\n然后你和同事A、同事B一起顺着业务流程，找到了负责上层模块的\u0026hellip;\u0026hellip;\n最后，你和同事ABC\u0026hellip;一起找到了产品，产品一脸懵逼：“那没办法，就改需求吧\u0026hellip;\u0026hellip;”\n你眼看着所剩无几的迭代时间，生无可恋地掏出手机，发个微信取消了这周末的相亲\u0026hellip;\n不知道程序员xdm有没有经历过这样的场景，如果各位程序员xd没有经历过这样的场景，那真的是恭喜你了，且行且珍惜！从毕业后参加工作开始，我是真的经历太多了，太痛了！\n我之后不断学习各种方法，尝试去破解这样的困局。虽然说，工作中的问题很多，但是能解决一个是一个，后面再慢慢跟各位分享其他问题中我的解决方案。\n所以，本篇文章将分享一波关于这类问题我的解决方案。谨代表个人主观观点。\n痛点 需求是用户的痛点，但是在这个场景下，是程序员的痛点\u0026hellip;\n那么，仔细分析一下，这个场景下的痛点，到底是什么呢？我认为是如下两点：\n产品给到的需求无法自洽，且场景覆盖不够 开发团队的技术评审和技术文档不到位 开发各自按照模块开发，忽略外部环境，仅仅当各自开发完成后联调时候才会组装应用，发现问题 当然，可能有程序员xd会疑问：这种问题不是靠严谨的开发流程就可以避免吗？\n理论上来说是这样的，但是以我个人经历而言，不管是大团队还是小团队，总有很多不稳定的因素，比如说迭代周期、协作流程的规范性等等。\n特别是在创业团队，或者有些项目特别着急的时候，经常是没有足够的时间给到团队的各个角色去充分准备的，甚至为了赶时间，会精简一些环节甚至直接去掉。这种时候出现这种问题导致改需求，往往是非常可怕的，后果也往往是开发团队加班。\n解决方案 我目前发现且实践后效果较好的方案，就是“曳光弹式开发”。\n什么是曳光弹 经常关注军事的小伙伴儿，应该了解，曳光弹是一种运用于军事场景的特殊子弹。\n我们都知道武器发射时需要瞄准，比如枪就通过照门和准星来瞄准，而坦克和装甲车以及飞机都有专用的瞄准具，非常复杂。对于轻武器来说，一般攻击距离都比较近，使用自带的机械瞄准具或者外加的光学瞄准镜都足够，但是在距离稍远的时候瞄准镜显然不够。而对于飞机和战斗机来讲，在空中飞行时飞行姿态变化多样，有时候进攻的时间很短，需要快速射击并且调整弹道，这时候就需要可以发光的曳光弹。\n曳光弹正如其名，可以发光而且指示弹道。曳光弹的结构比一般子弹更加复杂。子弹的弹壳部分和一般子弹一样，前半部分是钢心或者铅心的弹头，但是在后部有一个空腔，一般称作曳光管，里面填充着曳光剂。曳光剂的成分还比较复杂，一般来说主要成分是镁粉和铝镁合金粉，用来燃烧，除此之外还有硝酸锶。这样一来，燃烧的时候硝酸锶就会发出红光。大家平时看到的很多曳光弹还有黄光和绿光，加入钠盐就会发出黄光，而加入铜盐就会发出绿光。除此之外还在表面加入一层过氧化钡，以保证曳光剂被点燃。\n对于机枪手来说，如果射击距离较远，自然不能选择过于精确的设计方式，也就是说不能靠瞄准具来射击。而一般的机枪主要起压制和面杀伤作用，加入曳光弹就是机枪手更加快速方便的控制弹道，随时变化攻击的方向。如果没有曳光弹的话，射手根本无法发现自己的子弹弹道，也就很难去调整弹道。毕竟枪械射击温度升高之后，弹道会有所变化，不同的弹药不同的枪管也都会改变子弹的弹道，如果仅仅依靠枪械自身的瞄准具去调整反而会适得其反，而曳光弹就很好的解决了这个问题。\n在开发中的作用 理解曳光弹本身在军事中的作用后，我们再来看曳光弹式开发如何在开发中起作用。\n开发团队在接手到产品给到的业务需求后，特别是构建一些以前从未做过的东西时，对这个产品/功能的最终成效是模糊的。\n程序员就像坦克上的机枪手一样，在尝试在黑暗中击中目标。但是如果像文章一开始的时候，大家先埋头写自己的模块，然后再联调，最终发现问题，感觉就像一上战场，大家都朝着各自理解的方向拼命清空弹夹，击中目标的寥寥无几，最后受伤的还是自己。\n所以，此时，就需要先使用几颗曳光弹，去击中目标，在黑暗中划出轨迹，开发团队再调整方向，对着目标集中火力。\n如何应用 非常简单！步骤如下：\n找出级别最高的需求 以完成最基础的完整功能为目标，从前端到部署，开发一个可以运行的骨架 最后上相关需求的测试案例 这样，射出一颗曳光弹，穿透客户端、后端、数据库、运维、测试等不同层面。一旦击中目标——即符合用户需求，后续的任务便大都是搬砖的活儿，去丰富这个骨架。\n曳光弹并不是总能击中目标的，中途若是发现未能击中目标，便可在前期以极小成本去调整曳光弹的方向，继续发射曳光弹。\n如果你要问，什么是“最基础的完整功能”，那么可以这么说，那么举个例子：前端不要任何样式，直接能够满足比如表单功能即可，后端不用任何校验，能够处理和传递数据即可。\n总结 为了解决文章开头的问题，需要使用曳光弹式开发，先开发一个骨架，确认满足需求后，即可继续丰富骨架，完成产品。\n作为团队的一员，团队的每一个角色都很重要，程序员跟产品也是需要紧密协作，互帮互助，才能使得产品更好，也使得业绩更好。\n","date":"2023-12-05T15:56:29Z","image":"https://blog.hunterji.com/p/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%AA%8C%E8%AF%81%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82/cover_hud87aacab5fb26efd5717fb6564f41dda_2230004_120x120_fill_box_smart1_3.png","permalink":"https://blog.hunterji.com/p/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%AA%8C%E8%AF%81%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82/","title":"程序员如何快速验证业务需求?"},{"content":"一. 前言 最近很多小伙伴儿咨询我关于学习技术方面的问题，我都一一回复了。这里也专门出一个总结，关于我个人这些年入门新的编程语言和框架的经验和技巧，来跟大家分享一下，希望能够所有帮助。\n本次分享分为两个时期：\n有编程经验时期 新手时期 二. 有编程经验时期 当我有了一定开发经验后，去学习一个新的编程语言或者框架，我会注意如下两点：\n1. 寻找共性 编程语言 所有的编程语言或者框架，都不是凭空产生的。当前比较流行的语言，大都是类C语言，比如我们常见的Java、Python、JavaScript、Golang等等。\n所以，我们学习的编程语言，除了特有的特性，大都是相似的，也就是它们的共性。我们只要理解和掌握这些类C语言的共性，就可以很快地掌握一门新的编程语言。\n那么，哪些是共性呢？比如说变量、常量、运算符、判断、循环、函数、面向对象等等。\n我们在学习一门新的编程语言的时候，是不是必然要学习如上这些共性的知识点？\n那么，当你已经有一个编程语言的基础后，当你在学习和写代码的时候，这些共性可以直接使用你已学会的编程语言的知识去代入。\n举个例子，比如我已经会Go了（不过，当你先学Go的话，可能不太知道面向对象是什么/狗头），要去学一下Python。\n我需要做的就是代入：\nGo语言声明变量是a := 1，考虑到Python没有强类型，那么就直接a = 1就完事了。\nGo语言声明函数是func aFunction(username String) {}，那么Python不过是换了个关键词，去掉了强类型，变成def aFunctino(username):，当然Python如果要申明类型也是可以的，写成def login(username: str):。\n其中，比如运算符大都是一样的，判断也是类似。\n但是突然你发现，怎么Python的循环不一样，然后发现Python的循环好方便，但是其实原理还是和Go一样的。甚至，当你遇到不知道怎么处理的时候，直接来一波for (i := 0; i \u0026lt; count; i++)。当然，Python没法这么写。\n除了我举的这些例子，还有比如正则、数据类型、数据结构等等，都可以作为共性来代入。\n框架 其实，框架也是如此。此处以web框架为例，比如Python的Flask、Django、FastApi，Go的Gin，Node的express，Java的SpringBoot等，都是比较熟知的框架。\n这些Web框架，都是依托于网络的，大都是http(s)请求，甚至其他TCP请求。我们可以只在网络层面来看，它们共性就是request和response。所以在网络层面就可以理解为，后端web框架就是一个接收request和response的东西。\n那么，看具体框架的功能上，可以抽象出路由、中间件。\n所以，对于一个web框架，其共性为request、response、路由、中间件。\n因此，我们不管是使用Flask、Gin还是SpringBootd等，可以使用我们已有的框架知识去代入：\n如何接收request，比如获取request body、headers等 如何使用中间件处理，比如使用中间件鉴权、传递上下文等 如何配置路由，让接口对外暴露 如何返回response，比如返回http status code、json等 那么，就可以完成一个新的web框架的入门了。\n其它 除了编程语言和框架，其实还有很多别的都是拥有共性，可以快速入门的，比如Nginx和Apache，比如Linux发行版本，比如Kong和ApiSix，比如不同的数据库等等。甚至最近我发现，wasm并不是前端特有的，EBPF也在用wasm。\n2. 看官方文档 编程语言的情况还比较少，更多是学习框架时，一定要看官方文档。\n网上虽然有很多教程，但是毕竟是二次加工的，可能存在信息遗漏、版本更新等等问题。\n官方文档可能比较生涩，但是它是最全最新的一手文档，会非常有助于少走弯路。\n再次强调，一定要看官方文档！\n二. 新手时期 当我还是新手的时候，我其实也常常苦恼于入门——教程看了好多遍，跟着教程敲了一遍又一遍，感觉还是只会基础，自己想写点什么却不会。\n后来，当我入门一段时间后，我返回去想一想，才想明白一些技巧。\n所以，以我的经历，总结如下步骤：\n1. 仅学基础 一开始的时候，我也是不停地啃教程，不管是文档还是视频，但是发现我还是只会基础理论知识，那些高级特性案例都敲了，却并不明白什么意思。\n后来，我就发现，对于我而言，并不需要学太多，只要学会基础即可，甚至基础也不用太深入。\n2. 自己构思写一个项目 跟着教程敲代码，效果甚微。\n要自己构思一个项目，比如写一个TODO，写一个命令行聊天工具，写一个博客等等简单的程序。最好是自己感兴趣的领域。\n但是，需要注意的是，一定要自己去构思如何写：\n你准备写一个什么程序？要达到什么效果？ 写这个程序有哪些功能？ 这些功能都应该怎么实现？ 然后，直接开始写代码！哪怕只是创建了几个文件。\n只有自己思考的，才能深刻理解和记忆。\n3. 不会就去学，不懂就复制过来用 当然，因为仅仅学了基础，你会发现很多功能并不会，甚至比如如何读取一个文件都不会。\n如果这时候，遇到不会的，就当场去学，哪怕是高级特性，学到把不会的这个点能做出来为止。\n如果一个功能不懂什么意思，搞不明白，那么直接复制过来，调试到能满足功能为止，然后将这段代码和这个场景记住。\n4. 多写代码，迈过门槛 我一直觉得写代码有一个门槛，在迈过门槛前，学习会非常困难，但是，一旦迈过这个门槛，你就会发现，学起来异常轻松，你所学的技术可以（相对）融会贯通。\n那么迈过这个门槛的方法就是：重复2和3两个步骤，多写代码，多思考。\n是的，不断重复，然后可能某一天，当你对你学的技术恍然大悟的时候，那么其实就是迈过了那个门槛。\n然后，之后便是更深入地学习了。\n三. 总结 一路走来，我觉得最重要的是“多写代码，多思考”。不少代码写到最后甚至都是肌肉记忆了，但是代码还是会变的，自己思考的方式和过程，自己沉淀的知识才是最宝贵的，足以支撑我能够不断学习新的技术，适应新的模式。\n","date":"2023-11-29T21:10:40Z","image":"https://blog.hunterji.com/p/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%96%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6/cover_hu289f93b8ec41ea81055c11038b70f240_213994_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.hunterji.com/p/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%96%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6/","title":"如何快速入门新的编程语言和框架？"},{"content":"前言 在上一篇文章《使用Rust和WebAssembly整花活儿(三)——Rust与JS交互》中，讲述了Rust与JS的交互，包括Rust与JS的函数相互调用，比较炸裂的功能就是使用JS调用Rust的struct，JS本身连struct都没有，居然可以调用Rust的struct，这对于Rust开发者的开发体验而言，是真的很棒！\n基于前面的系列文章，已经足以使用Rust开发一个完整的功能了。\n但是，在前端引入wasm文件时，还是可能存在一些问题，比如wasm文件较大，导致网页访问时间较长，用户体验较差。本篇文章将会通过多种途径来减少Rust编译wasm文件的体积，以减少前端加载wasm文件的时间。\n曾经一段时间，我一直用Go开发WebAssembly，其编译后的wasm文件体积还是较大的，为了减少wasm文件的体积真是煞费苦心，1xMB大小的wasm文件真的是太痛了\u0026hellip;\u0026hellip;但是体积优化往往都会指向一条“充满魅惑的不归路”——换成Rust开发😆！如果你已经在用Rust开发WebAssembly了，那么恭喜你，对Go而言，在wasm体积上，你已经赢在起跑线上了。\n环境 Rust 1.70.0 wasm-bindgen 0.2.87 查看体积 在真正去减少体积前，我们需要来先看一下，当前情况下体积是多少，方便后续对比前后体积。\n查看体积的方式有多种，这里推荐几个，（Linux和MacOS）使用其一即可。\nls 可以使用ls -l或者ll：\n1 2 $ ll pkg/hello_wasm_bg.wasm -rw-r--r-- 1 kuari staff 23K Jul 20 21:52 pkg/hello_wasm_bg.wasm stat 1 2 $ stat pkg/hello_wasm_bg.wasm 16777222 142141572 -rw-r--r-- 1 kuari staff 0 23347 \u0026#34;Jul 20 21:52:53 2023\u0026#34; \u0026#34;Jul 20 21:52:01 2023\u0026#34; \u0026#34;Jul 20 21:52:01 2023\u0026#34; \u0026#34;Jul 20 21:52:01 2023\u0026#34; 4096 48 0 pkg/hello_wasm_bg.wasm wc 1 2 $ wc -c pkg/hello_wasm_bg.wasm 23347 pkg/hello_wasm_bg.wasm 以wc为例，当前该wasm文件体积为23347b。\n代码层面 Link-Time Optimization (LTO) 是指在程序链接时进行的一种过程间优化（interprocedural optimization）。它允许编译器在链接阶段对多个编译单元进行优化，从而提高程序的性能、可靠性和安全性。\n从代码层面优化，主要是利用LTO（Link-Time Optimization）。\n代码内 在Cargo.toml中开启LTO：\n1 2 [profile.release] lto = true 开启LTO虽然能够减少编译后的体积，但是也会增加编译时间。\nLTO开启后，默认是在减少一定程度的编译体积的情况下，要确保编译的时间。如果你的需求就是更小的体积，而不是较短的时间，那么，可以通过手动指定编译等级来让LTO作出改变。\n在代码内可以使用如下等级：\ns：默认的 LTO 等级。它会进行最基本的 LTO 优化，包括内联函数、函数重写、数据重排等 z：最高级的 LTO 等级。它会进行更复杂的 LTO 优化，包括死代码消除、内存分配优化、安全性优化等 那么可以在Cargo.toml中这么配置：\n1 2 3 [profile.release] lto = true opt-level = \u0026#39;z\u0026#39; 原始的文件体积是23347b，现在编译后看一下体积：\n1 2 $ wc -c pkg/hello_wasm_bg.wasm 19879 pkg/hello_wasm_bg.wasm 很明显是减少体积！但是，使用z等级并不代表一定每次体积都会比s小的，有时候s也会比z小，这需要视代码情况而定。\n代码外 在代码外，可以使用wasm-opt来进行优化，其可以对 WebAssembly 模块进行多方面的优化，当然本篇文章中重点在体积方面（挖个坑，后面再详聊/狗头）。并且wasm-opt可以对所有符合WebAssembly规范的wasm文件进行优化，所以，就算你不是Rust写的，那也可以用其进行优化。（想想我曾经Go写的wasm，也是有多一个法子可以优化一把了\u0026hellip;\u0026hellip;）\n首先，来看一下wasm-opt的基本优化参数：\n-o：指定优化后的模块输出文件 -O：启用默认优化，等同于-Os参数 -O0：不进行任何优化 -O1：进行一些基本的优化，例如内联函数优化和死代码消除优化 -O2：进行更为彻底的优化，例如函数重写、数据重排、内存分配优化等 -O3：进行最为彻底的优化，包括一些可能影响程序功能的优化 -O4：与 -O3 相同，但会启用更为激进的优化 -Os：优化目标是减小代码大小，会进行一些可能影响性能的优化 -Oz：与 -Os 相同，但会启用更为激进的优化 基于本篇文章主题，此处将使用-Os和-Oz两种参数，其于上述\u0026quot;代码内\u0026quot;的等级是对应的。\n此处以原始wasm文件，以-Oz参数来执行一下，看一下对比效果：\n1 2 $ wc -c pkg/output.wasm 23194 pkg/output.wasm 再以上述开启“代码内“LTO编译后的wasm文件，以wasm-opt执行一下，看一下对比效果：\n1 2 $ wc -c pkg/output.wasm 19871 pkg/output.wasm 总体而言，wasm文件的体积越来越小。只是当前我这里的案例，是沿用系列文章内容的代码，没有什么实际性复杂代码，再者本身体积已经很小了，所以不会特别有效果。\n网络层面 网络层面的话，就是众所周知的在网络传输时，客户端和服务端约定相同的压缩算法，然后服务端给出时进行压缩，客户端接收时进行解压。网络层面可以对传输报文进行压缩，但不丢失信息。\n比如大家都很熟悉的gzip压缩算法，不过，压缩算法有好几种：\ngzip compress deflate br 其中gzip也是压缩率最高的了，此处就以gzip为例。\n在网络层面，将wasm文件以gzip压缩，减少其在传输时的体积。虽然减少了传输时的体积，但是浏览器在拿到压缩后的数据，需要消耗一定性能来解密。\n开启GZIP 开启GZIP其实简单，只要前后端约定好都用gzip就行了。\n首先，前端请求wasm文件时，需要在request header中放入浏览器支持的压缩模式：\n1 Accept-Encoding: gzip, deflate 接着，服务端收到这个请求后就可以给出服务端也支持的压缩模式，并告诉浏览器服务端将会用什么压缩模式。\n跟浏览器通信的方式就是将信息塞到respone header里面：\n1 Content-Encoding: gzip 这样就开启GZIP了。\n然后，就是浏览器接收到response的body和header，知道后端使用gzip压缩的，那么浏览器就会自动用gzip来解压，拿到完整的数据了。\n服务端支持 或许你会想问，浏览器能自动解密，那服务端怎么自动加密呢？要后端写代码让文件加密吗？\n那当然不是了，直接让http server来完成这个操作。此处以耳熟能详的Nginx为例。\n最简单的就是一行配置开启gzip了：\n1 gzip on; 也可以指定gzip的一些参数，比如可以加密的类型、最小加密长度等等：\n1 2 3 4 5 gzip on; gzip_types text/plain application/xml; gzip_proxied no-cache no-store private expired auth; gzip_min_length 1000; ... 更多的http server配置，可以去各自官方文档查阅。\n物理层面 你可能会惊奇，什么物理层面？！\n没错，真就是物理层面——直接对wasm文件进行gzip物理压缩！哈哈，这个方法也真是绝了，我之前在Go开发wasm时，寻找减少体积的时候发现的，如果你的wasm已经优化得穷途末路了，不妨大胆试试这个方案。😆\n还记得上面章节“网络层面“中，有个问题就是是否需要手动压缩，那么这里就是全程手动压缩和解压缩了，哈哈。\n物理压缩 首先，是对wasm文件进行物理层面的gzip压缩，此处先使用原始的wasm（23347b）：\n1 gzip -c pkg/hello_wasm_bg.wasm \u0026gt; pkg/output.gz 然后，看一下其体积：\n1 2 $ wc -c pkg/output.gz 10403 pkg/output.gz 效果卓群，从23347b减少到了10403b！\n然后来把上述“代码层面”的优化来一遍，看一下最后的体积：\n1 2 $ wc -c pkg/output.gz 9237 pkg/output.gz 效果更加卓群了，从19871b减少到了9237b了！\n所以，此处就是对wasm文件进行物理压缩并存储，然后浏览器请求时，直接请求到.gz文件。\n物理解压 浏览器拿到.gz文件后，需要物理解压。\n这里推荐使用pako这个前端库，对.gz文件进行解压：\n1 2 3 4 5 6 7 8 9 async function gunzipWasm() { const res = await fetch(\u0026#34;target.gz\u0026#34;) let buffer = await pako.ungzip(await res.arrayBuffer()) // A fetched response might be decompressed twice on Firefox. // See https://bugzilla.mozilla.org/show_bug.cgi?id=610679 if (buffer[0] === 0x1F \u0026amp;\u0026amp; buffer[1] === 0x8B) {buffer = pako.ungzip(buffer)} return buffer } 之后就可以直接使用了。\nBUFF叠加 此处直接将上述所有方法都用起来，直接叠加buff，来看看当前（本系列文章积累的）这个案例能减少多少体积。在“物理层面”章节中，已经累加除了“网络层面”的buff了，所以可以直接使用其结果。而“网络层面”章节中，以gzip来压缩，将gzip的压缩率以40%来估算。\n那么最终该案例的wasm体积将在5542b，压缩率大约在77%！\n当然，还要算上一个初始的语言buff——Rust，使用Rust本身就已经导致wasm文件体积很小了。\n总结 本片文章中，从代码层面、网络层面、物理层面共三个层面介绍了对wasm文件的体积优化方案，其中共有四个方案。\n最后，当前（本系列文章积累的）该案例叠加了所有buff之后，能够减少77%的体积，真的感觉挺棒的了，哈哈。\n希望能够对各位有所帮助。\n","date":"2023-10-26T23:51:13Z","image":"https://blog.hunterji.com/p/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E5%9B%9B%E6%9B%B4%E5%B0%8F%E6%9B%B4%E5%B0%8F%E7%9A%84wasm%E6%96%87%E4%BB%B6%E4%BD%93%E7%A7%AF/cover_hu822cb824dae9cb9cc6f33de0e5ba4a75_1034399_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.hunterji.com/p/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E5%9B%9B%E6%9B%B4%E5%B0%8F%E6%9B%B4%E5%B0%8F%E7%9A%84wasm%E6%96%87%E4%BB%B6%E4%BD%93%E7%A7%AF/","title":"使用Rust和WebAssembly整花活儿(四)——更小更小的wasm文件体积"},{"content":"前言 在上一篇文章《使用Rust和WebAssembly整花活儿(二)——DOM和类型转换》中，描述了使用Rust操作DOM，并实现Rust与JS类型转换的多种方法。\n在开发 Web 应用程序时，使用 Rust 编写的 Wasm 模块可以提供更高的性能和更好的安全性。但是，为了与现有的 JavaScript 代码集成，必须实现 Rust 与 JS 之间的交互。Rust 与 JS 交互的主要目的是将两种语言的优势结合起来，以实现更好的 Web 应用程序。\n基于上一篇文章中，Rust与JS的类型转换的多种方法，本篇文章继续深入Rust与JS的交互。\n首先，Rust与JS的类型转换，可以实现变量的传递，那么变量是要用在哪里呢？那必然是函数了！\n所以，本篇文章来讲述一下Rust与JS的函数相互调用，基于此，可以实现大量日常功能开发。\n并且，还将会讲述一下，如何导出Rust的struct给JS调用。\n是的，没错，在JS调用Rust的struct！一开始看到这个功能的时候，我的脑子是有点炸裂的\u0026hellip;\u0026hellip;😳\n本篇文章中，将基于上一篇文章中创建的项目来继续开发。\n源码：github.com/Kuari/hello-wasm\n环境 Rust 1.70.0 wasm-bindgen 0.2.87 函数的相互调用 JS调用Rust函数 其实，在本系列文章的第一篇中，就是使用的JS调用Rust函数作为案例来演示的，这里依然以此为例，主要讲一下要点。\n首先，声明一个Rust函数：\n1 2 3 4 5 6 use wasm_bindgen::prelude::*; #[wasm_bindgen] pub fn add(a: i32, b: i32) -\u0026gt; i32 { a + b } 此处需要注意的要点如下：\n引入wasm_bindgen 声明一个函数，使用pub声明 在函数上使用#[wasm_bindgen]宏来将Rust函数导出为WebAssembly模块的函数 接着，编译成wasm文件：\n1 wasm-pack build --target web 然后，在JS中调用该函数：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { add } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const result = add(1, 2); console.log(`the result from rust is: ${result}`); } run(); \u0026lt;/script\u0026gt; 最后，启动http server，在浏览器的控制台中可以看到the result from rust is: 3，表明调用成功！\nRust调用JS函数 ###1 指定JS对象\n在Rust中调用JS函数，需要进行指定JS对象，也就是说，得明确告诉Rust，这个JS函数是从JS哪儿拿来的用的。\n主要在于下面两个方式：\njs_namespace: 是一个可选的属性，用于指定一个JavaScript命名空间，其中包含将要在wasm模块中导出的函数。如果没有指定js_namespace，则所有的导出函数将被放置在全局命名空间下。 js_name: 是另一个可选属性，它用于指定JavaScript中的函数名称。如果没有指定js_name，则导出函数的名称将与Rust中的函数名称相同。 ###2 JS原生函数\n对于一些JS原生函数，在Rust中，需要去寻找替代方案，比如我们上一篇文章中讲的console.log()函数，是不是觉得好麻烦啊！\n那么，你想直接在Rust中调用JS原生函数吗？！\n此处，就以console.log()函数为例，直接在Rust中引入并调用，免去替代方案的烦恼。\n首先，给出Rust代码：\n1 2 3 4 5 6 7 8 9 10 #[wasm_bindgen] extern \u0026#34;C\u0026#34; { #[wasm_bindgen(js_namespace = console)] fn log(message: \u0026amp;str); } #[wasm_bindgen] pub fn call_js_func() { log(\u0026#34;hello, javascript!\u0026#34;); } 如上代码中，call_js_func函数，顾名思义，此处是调用了js函数，并传入参数hello, javascript!。\n那么，call_js_func函数上方的代码，我们来一步步解析一下：\n第一行代码#[wasm_bindgen]是Rust的属性，它告诉编译器将函数导出为WebAssembly模块 extern \u0026quot;C\u0026quot;是C语言调用约定，它告诉Rust编译器将函数导出为C语言函数 #[wasm_bindgen(js_namespace = console)]告诉编译器将函数绑定到JavaScript中的console对象 fn log(message: \u0026amp;str)是一个Rust函数，它接受一个字符串参数，并将其打印到JavaScript中的console对象中 此处与JS交互的关键是js_namespace。在Rust中，js_namespace是用于指定JavaScript命名空间的属性。在WebAssembly中，我们可以通过它将函数绑定到JavaScript中的对象上。\n在上述代码中，#[wasm_bindgen(js_namespace = console)]告诉编译器将函数绑定到JavaScript中的console对象。这意味着在JS中使用console.log()函数来调用Rust中的log()函数。\n因此，类似的原生函数，都可以使用该方法来实现调用。\n最后，我们在JS中调用下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { call_js_func } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); call_js_func(); } run(); \u0026lt;/script\u0026gt; 可以在浏览器的控制台中看到hello, javascript!。妙啊！\n其实对于console.log()而言，还有另一种调用方式，那就是使用js_namespace和js_name同时指定。\n或许，你会问，这有什么不同吗？是的，这有些不同。\n不知道你是否发现，当前这个案例中，指定了js_namespace为console，但是真实执行的函数是log()，那么这个log函数的指定，其实是体现在Rust中同样的函数名log。也就是说，该案例的log()就是console.log()中的log()。\n我们来换个名字看看，将原来的log()换成log2()：\n1 2 3 4 5 6 7 8 9 10 #[wasm_bindgen] extern \u0026#34;C\u0026#34; { #[wasm_bindgen(js_namespace = console)] fn log2(message: \u0026amp;str); } #[wasm_bindgen] pub fn call_js_func() { log2(\u0026#34;hello, javascript!\u0026#34;) } 然后编译后去控制台看看，就会看到报错：\n1 TypeError: console.log2 is not a function 因此，当我们使用js_namespace和js_name结合的方式，在此处是可以进行自定义函数名的。\n看一下Rust代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[wasm_bindgen] extern \u0026#34;C\u0026#34; { #[wasm_bindgen(js_namespace = console)] fn log(message: \u0026amp;str); #[wasm_bindgen(js_namespace = console, js_name = log)] fn log_str(message: \u0026amp;str); } #[wasm_bindgen] pub fn call_js_func() { log_str(\u0026#34;hello, javascript!\u0026#34;) } 此处，重新定义了一个函数log_str，但是其指定了js_namespace = console和js_name = log，那么此处，就可以使用自定义的函数名。\n直接编译后，在控制台看一下，可以直接看到正常输出：hello, javascript!。\n总结一下，如果没有指定js_name，则 Rust 函数名称将用作 JS 函数名称。\n###3 自定义JS函数\n在一定场景下，需要使用Rust调用JS函数，比如对于一些对于JS而言更有优势的场景——用JS操作DOM，用Rust计算。\n首先，创建一个文件index.js，写入一个函数：\n1 2 3 export function addIt(m, n) { return m + n; }; 当前的文件结构关系如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . ├── Cargo.lock ├── Cargo.toml ├── README.md ├── index.html ├── index.js ├── pkg │ ├── README.md │ ├── hello_wasm.d.ts │ ├── hello_wasm.js │ ├── hello_wasm_bg.wasm │ ├── hello_wasm_bg.wasm.d.ts │ └── package.json ├── src │ └── lib.rs └── target ├── CACHEDIR.TAG ├── debug ├── release └── wasm32-unknown-unknown 其中，index.js和lib.rs，以及hello_wasm_bg.wasm都是不在同一级别的，index.js都在其它两个文件的上一级。记住这个机构关系！\n然后，在lib.rs中，指定函数：\n1 2 3 4 ##./index.js\u0026#34;)] extern \u0026#34;C\u0026#34; { fn addIt(m: i32, n: i32) -\u0026gt; i32; } 其中，raw_module = \u0026quot;../index.js\u0026quot;的意思是，指定对应的index.js文件，大家应该清楚，此处指定的是刚刚创建的index.js。raw_module的作用就是用来指定js文件的。\n这段代码在前端，可以等同于：\n1 import { addIt } from \u0026#39;../index.js\u0026#39; 这样在前端都不用引入了，直接在Rust中引入了，感觉还有点奇妙的。\n接着，在Rust调用该函数：\n1 2 3 4 #[wasm_bindgen] pub fn call_js_func() -\u0026gt; i32 { addIt(1, 2) } 最后，在前端调用，编译后，在浏览器的控制台中可以看到输出结果了！\n总结一下，这里有几个注意点：\nJS的函数必须要export，否则将无法调用； raw_module只能用来指定相对路径，并且，大家可以在浏览器的控制台中注意到，此处的../的相对路径，其实是以wasm文件而言的相对路径，这里一定要注意呀！ JS调用Rust的struct 现在，来点炸裂的，JS调用Rust的struct？！\nJS中连struct都没有，这玩意儿导出来会是什么样，得怎么在JS中调用呢？！\n首先，定义一个struct，并且声明几个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #[wasm_bindgen] pub struct User { name: String, age: u32 } #[wasm_bindgen] impl User { #[wasm_bindgen(constructor)] pub fn new(name: String, age: u32) -\u0026gt; User { User { name, age } } pub fn print_user(\u0026amp;self) { log(format!(\u0026#34;name is : {}, age is : {}\u0026#34;, self.name, self.age).as_str()); } pub fn set_age(\u0026amp;mut self, age: u32) { self.age = age; } } 此处，声明了一个struct名为User，包含name和age两个字段，并声明了new、print_user和set_age方法。\n其中还有一个未见过的#[wasm_bindgen(constructor)]，constructor用于指示被绑定的函数实际上应该转换为调用 JavaScript 中的 new 运算符。或许你还不太清晰，继续看下去，你就会明白了。\n接着，在JS中调用这个struct，和其方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; function addIt2(m, n) { return m + n; }; import init, { User } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const user = new User(\u0026#39;kuari\u0026#39;, 20); user.set_age(21); user.print_user(); } run(); \u0026lt;/script\u0026gt; 可以看到，这里的用法就很熟悉了！\n大概想一下，在Rust中要如何调用？也就是直接new一个——User::new('kuari', 20)。\n此处在JS中，也是如此，先new一个！\n然后很自然地调用struct的方法。\n编译后，打开浏览器，可以在控制台看到输出：name is : kuari, age is : 21。\n其实，或许大家会很好奇，起码我是非常好奇的，Rust的struct在JS中到底是一个怎样的存在呢？\n这里直接添加一个console.log(user)，就可以在输出看到。那么到底在JS中是一个怎样的存在呢？请各位动手打印一下看看吧！:P\n总结 本篇文章中，主要讲述了Rust与JS的交互，体现在Rust与JS的相互调用，这是建立在上一篇文章中类型转换的基础上的。\nRust与JS的函数相互调用的学习成本还是较大的，而且对比Go写wasm，Rust的颗粒度是非常细的，几乎可以说是随心所欲了。\n比较炸裂的就是Rust的struct导出给JS用，这对于Rust与JS的交互而言，还是非常棒的体验。\n","date":"2023-06-27T00:11:12Z","image":"https://blog.hunterji.com/p/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E4%B8%89rust%E4%B8%8Ejs%E4%BA%A4%E4%BA%92/cover_hu822cb824dae9cb9cc6f33de0e5ba4a75_1034399_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.hunterji.com/p/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E4%B8%89rust%E4%B8%8Ejs%E4%BA%A4%E4%BA%92/","title":"使用Rust和WebAssembly整花活儿(三)——Rust与JS交互"},{"content":"前言 在上一篇文章《使用Rust和WebAssembly整花活儿(一)——快速开始》中，描述了如何创建项目和快速生成wasm并在前端中使用，迈出了整花活儿的第一步。\n在开发 Web 应用程序时，使用 Rust 编写的 Wasm 模块可以提供更高的性能和更好的安全性。但是，为了与现有的 JavaScript 代码集成，必须实现 Rust 与 JS 之间的交互。Rust 与 JS 交互的主要目的是将两种语言的优势结合起来，以实现更好的 Web 应用程序。\n本篇文章中，将基于上一篇文章中创建的项目来继续开发。\n源码：github.com/Kuari/hello-wasm\n环境 Rust 1.70.0 wasm-bindgen 0.2.87 web-sys 0.3.64 DOM 配置依赖 要操作DOM，需要引入新的依赖web-sys，因此，可以配置Cargo.toml中依赖如下：\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [] } 你或许会好奇，这个features是什么，讲真，我一开始很好奇，又没看到什么特别的说明，试错才发现，原来是要手动引入功能依赖\u0026hellip;比如说，当你需要在Rust中使用JS的console，那么你需要在features中加入console。\n获取Document 在Rust中使用Document，我们需要按照上一步的说明，添加features。那么这里有一个依赖关系，首先在Rust中获取window，然后再获取document。\n因此，添加features后如下：\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;] } 然后在lib.rs中创建一个函数，用来调用document：\n1 2 3 4 5 #[wasm_bindgen] pub fn update_message() { let window = web_sys::window().expect(\u0026#34;Failed to load window\u0026#34;); let document = window.document().expect(\u0026#34;Failed to load document\u0026#34;); } 那么，现在就是在Rust中解锁了document，就可以在前端为所欲为了！\n操作Element 那么开始操作一波，首先得获取到Element\u0026hellip;\u0026hellip;\n是的，你没有想错，继续来添加features吧，此处要添加一个Element：\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;] } ok，那么继续。此处设定函数传入两个参数selector和message，然后通过selector获取element，更新值为message参数的值。完整函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 #[wasm_bindgen] pub fn update_message(selector: \u0026amp;str, message: \u0026amp;str) { let window = web_sys::window().expect(\u0026#34;Failed to load window\u0026#34;); let document = window.document().expect(\u0026#34;Failed to load document\u0026#34;); let element = document.query_selector(selector).expect(\u0026#34;Failed to load element\u0026#34;); if let Some(element) = element { element.set_inner_html(message); } else { panic!(\u0026#34;Failed to set inner html\u0026#34;) } } 编译 将写完的Rust项目编译成wasm：\n1 wasm-pack build --target web 在html中调用 基于上一篇文章的项目中的html，此处添加一个div，id为message，添加调用wasm的update_message函数，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { update_message } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; // 引入update_message函数 const run = async () =\u0026gt; { await init(); update_message(\u0026#39;#message\u0026#39;, \u0026#39;\u0026lt;h1\u0026gt;Hello, Rust!\u0026lt;/h1\u0026gt;\u0026#39;); // 调用update_message函数 } run(); \u0026lt;/script\u0026gt; 在浏览器验证 启动一个http server，然后在浏览器查看，可以看到在页面上出现一个h1标签的Hello, Rust!。\n发现更多方法 按照文章来写的过程中，你应该会发现一个问题——怎么这些方法没有补全？！\n是的，没错的，（至少我发现）当前web-sys并没有补全，所以只能结合开发者优秀的前端技能和丰富的官方文档来开发了。\nRust与JS的类型相互转换 对于wasm而言，性能固然是提升的，但是类型转换一直是个问题。当大量数据需要在wasm/js中进行类型转换时，这对性能来说，真的是个灾难。之前在使用go开发wasm时，就遇到过这样的问题，需要用官方的方法来进行手动类型转换，然而wasm处理的是一个很大的数据量\u0026hellip;\u0026hellip;\n不过好在Rust的类型支持真的挺丰富的！\n基础类型 基础类型挺简单的，而且Rust的范性也很好地支持了很多类型。如下是基础类型映射表：\nRust类型 JavaScript类型 i8 number i16 number i32 number i64 BigInt u8 number u16 number u32 number u64 BigInt f32 number f64 number bool boolean char string \u0026amp;str string String string \u0026amp;[T] 例如：\u0026amp;[u8] [T] 例如：Uint8Array Vec Array 基础类型转换示例 在lib.rs文件中，创建一个函数，挑选几个类型作为参数传入，然后将其读取并打印：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[wasm_bindgen] pub fn print_values(js_number: i32, js_boolean: bool, js_uint8_array: \u0026amp;[u8], js_number_array: Vec\u0026lt;i32\u0026gt;) { println!(\u0026#34;js number: {}\u0026#34;, js_number); println!(\u0026#34;js boolean: {}\u0026#34;, js_boolean); for item in js_uint8_array { println!(\u0026#34;js Uint8Array item: {}\u0026#34;, item); } for item in js_number_array { println!(\u0026#34;js number array item: {}\u0026#34;, item); } } 可以看到该函数传入了JS的number、boolean、Uint8Array和Array四个类型的参数。\n然后编译：\n1 wasm-pack build --target web 接着，在前端中引入函数并调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { print_values } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const jsNumber = 10; const jsBoolean = true; const jsUint8Array = new Uint8Array(3); jsUint8Array[0] = 1; jsUint8Array[1] = 2; jsUint8Array[2] = 3; const jsNumberArray = [30, 40, 50]; print_values(jsNumber, jsBoolean, jsUint8Array, jsNumberArray); } run(); \u0026lt;/script\u0026gt; 最后，启动http server并打开浏览器，在控制台可以看到\u0026hellip;看不到？！\n是的，没错，Rust的println!只会将打印的内容发送到Rust的标准输出流，而不是前端的控制台。如果想在控制台中打印，那么需要调用JS的console了。\n使用新的功能，第一步就是添加features，Cargo.toml中添加console如下：\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;, \u0026#34;console\u0026#34;] } 在Rust中调用console.log()如下：\n1 web_sys::console::log_1(\u0026amp;\u0026#34;Hello, Rust!\u0026#34;.into()); 此处将其封装成一个函数：\n1 2 3 fn console_log(message: String) { web_sys::console::log_1(\u0026amp;message.into()); } 然后，将示例函数的println改成console_log()和format!，函数代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[wasm_bindgen] pub fn print_values(js_number: i32, js_boolean: bool, js_uint8_array: \u0026amp;[u8], js_number_array: Vec\u0026lt;i32\u0026gt;) { console_log(format!(\u0026#34;js number: {}\u0026#34;, js_number)); console_log(format!(\u0026#34;js boolean: {}\u0026#34;, js_boolean)); for item in js_uint8_array { console_log(format!(\u0026#34;js Uint8Array item: {}\u0026#34;, item)); } for item in js_number_array { console_log(format!(\u0026#34;js number array item: {}\u0026#34;, item)); } } 最后，编译之后，打开浏览器，就可以在控制台看到输出：\n1 2 3 4 5 6 7 8 js number: 10 js boolean: true js Uint8Array item: 1 js Uint8Array item: 2 js Uint8Array item: 3 js number array item: 30 js number array item: 40 js number array item: 50 通用类型 Rust中提供了一个通用的类型——JsValue，可以作为任何JS类型。\n这里给一个简单的案例，设置一个函数，使用JsValue作为参数传入，并打印。\n创建函数：\n1 2 3 4 #[wasm_bindgen] pub fn print_js_value(val: JsValue) { console_log(format!(\u0026#34;{:?}\u0026#34;, val)); } 然后编译成wasm文件。\n在html中调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { print_js_value } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const jsNumber = 10; const jsBoolean = true; const jsUint8Array = new Uint8Array(3); jsUint8Array[0] = 1; jsUint8Array[1] = 2; jsUint8Array[2] = 3; const jsNumberArray = [30, 40, 50]; print_js_value(jsNumber); print_js_value(jsBoolean); print_js_value(jsUint8Array); print_js_value(jsNumberArray); } run(); \u0026lt;/script\u0026gt; 在html中，传入了不同类型的参数，但是在浏览器的控制台中可以看到，将所有不同类型的参数都打印出来了：\n1 2 3 4 JsValue(10) JsValue(true) JsValue(Uint8Array) JsValue([30, 40, 50]) Result Result在Rust中是一个很重要的存在，经常写Rust的话，也不想在写WebAssembly时改变开发习惯。\n其实对于JS而言，Result可以直接在catch中捕获到，只是说，这里我们需要定义好参数类型。\n####1 使用Result返回报错\n首先来一个只返回报错的场景：\n1 2 3 4 5 6 7 8 #[wasm_bindgen] pub fn only_return_error_when_result(count: i32) -\u0026gt; Result\u0026lt;(), JsError\u0026gt; { if count \u0026gt; 10 { Ok(()) } else { Err(JsError::new(\u0026#34;count \u0026lt; 10\u0026#34;)) } } 这里返回类型是Result，但是仅仅返回了一个错误。值得注意的是，这里的报错使用的类型是JsError，当然，这里也可以使用JsValue。\n然后在html调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { only_return_error_when_result } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); try { only_return_error_when_result(1); console.log(\u0026#39;1 is ok\u0026#39;); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 1: \u0026#39;, error); } try { only_return_error_when_result(100); console.log(\u0026#39;100 is ok\u0026#39;); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 100: \u0026#39;, error); } } run(); \u0026lt;/script\u0026gt; 这里调用了两次，第一次应当是错误的，第二次应该是正确的，并且都使用了catch来捕获错误。\n那么，在浏览器的控制台可以看到输出：\n1 2 An error is reported when the input parameter is 1: Error: count \u0026lt; 10 100 is ok ####2 使用Result返回正常值和错误\n那么，如果想既返回正常值，也想返回错误呢？Rust返回一个Result是没有问题，那么JS怎么解析呢？\n直接上Rust代码：\n1 2 3 4 5 6 7 8 #[wasm_bindgen] pub fn return_all_when_result(count: i32) -\u0026gt; Result\u0026lt;i32, JsError\u0026gt; { if count \u0026gt; 10 { Ok(count + 10) } else { Err(JsError::new(\u0026#34;count \u0026lt; 10\u0026#34;)) } } 该函数，获取到参数后，如果满足条件，加10后返回，否则报错。\n那么看看html中如何调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { return_all_when_result } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); try { const res = return_all_when_result(1); console.log(`get ${res}`); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 1: \u0026#39;, error); } try { const res = return_all_when_result(100); console.log(`get ${res}`); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 100: \u0026#39;, error); } } run(); \u0026lt;/script\u0026gt; 是的，没错，正常获取就行了\u0026hellip;\u0026hellip;/捂脸哭\n这里的调用，依然是，第一个是错误的，第二个是正确返回值的，并且都使用了catch来捕获错误。\n最后，就是在浏览器的控制台中看到：\n1 2 An error is reported when the input parameter is 1: Error: count \u0026lt; 10 get 110 直接引入JS类型 如果你想更直接一点，那么可以直接引入JS类型！这里主要是利用js-sys这个依赖，可以在官方文档上看到很多JS的类型和函数，直接引入即可使用。当然，一定场景下，直接引入的类型，是需要手动转换类型的。\n####1 配置依赖\n在Cargo.toml中添加js-sys依赖：\n1 2 3 4 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;, \u0026#34;console\u0026#34;] } js-sys = \u0026#34;0.3.61\u0026#34; ####2 Uint8Array\n首先以Uint8Array举例，在lib.rs头部引入类型：\n1 use js_sys::Uint8Array; 然后创建一个函数，参数和返回都是Uint8Array类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #[wasm_bindgen] pub fn print_uint8_array(js_arr: Uint8Array) -\u0026gt; Uint8Array { // new Uint8Array let mut arr = Uint8Array::new_with_length(3); // Uint8Array -\u0026gt; vec for (index, item) in js_arr.to_vec().iter().enumerate() { console_log(format!(\u0026#34;{} - the item in js_arr: {}\u0026#34;, index, item)); } // Avoid type conversion // Use the method of the type itself for index in 0..js_arr.length() { console_log(format!(\u0026#34;{} - the item in js_arr: {}\u0026#34;, index, js_arr.get_index(index))); } // vec -\u0026gt; Uint8Array let vec = vec![1, 2, 3]; let arr2 = Uint8Array::from(vec.as_slice()); arr = arr2.clone(); // Use the method of the type itself arr.set_index(0, 100); arr } 忽略该函数中无意义的逻辑和arr变量的警告，只是为了演示用法。\n可以在代码中看到，直接引入的Uint8Array有自己的方法，一定场景下，需要转换类型，但是最好避免进行类型转换，而直接使用其自带的方法。\n这里可以简要总结下，就是最好一定场景内全部使用直接引入的JS类型，或者直接全部使用Rust类型来代替JS类型，两者都存在场景下，手动转换类型是件很糟糕的事。\n####3 Date\nDate类型，在上面的篇章中都没有提及，这里可以直接引入JS的Date类型来使用。\n首先是引入类型：\n1 use js_sys::Date; 然后，创建一个函数，返回时间戳：\n1 2 3 4 5 #[wasm_bindgen] pub fn return_time() -\u0026gt; f64 { let date = Date::new_0(); date.get_time() } 接着，在html中调用：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { return_time } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); console.log(\u0026#39;current time: \u0026#39;, return_time()); } run(); \u0026lt;/script\u0026gt; 最后，在浏览器的控制台中，可以看到：\n1 current time: 1686979932833 总结 本文中，主要讲述了如何使用Rust来实现DOM操作，读者可以根据方法自己去找到合适的方法，来实现自己的场景。其次，还讲述了Rust与JS的类型转换，从基础的各自类型的映射，到Rust独有的Result，到直接引入JS类型。当然这里需要注意的是，直接引入JS类型和Rust的基础类型映射JS类型这两种方法尽量不要混用，混用会导致需要手动类型转换，造成性能损耗。\n至此，又向Rust和WebAssembly整花活儿迈进了一步~😼\n","date":"2023-06-18T18:18:31Z","image":"https://blog.hunterji.com/p/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E4%BA%8Cdom%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/cover_hu822cb824dae9cb9cc6f33de0e5ba4a75_1034399_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.hunterji.com/p/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E4%BA%8Cdom%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","title":"使用Rust和WebAssembly整花活儿(二)——DOM和类型转换"},{"content":"前言 WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。\n之前写过一篇文章，是关于如何使用golang来开发WebAssembly的——WebAssembly：未来前端开发的必备技能。\nRust和Go都可以用来开发WebAssembly，但它们有各自的优势和劣势。\nRust的优点：\n更快的性能和更小的二进制文件 更好的内存安全性 Go的优点：\n更容易上手和学习 更好的生态系统和社区支持 综合来说，如果你更注重性能和内存安全性，那么Rust可能是更好的选择。而如果你更注重开发效率和易用性，那么Go可能更适合你。当然，实际情况还需要根据具体的项目需求和团队情况来选择。\n因为一些工作需求，最近整了些rust的花活儿，这里系统地记录一下。当你遇到更注重性能和内存安全性的场景，希望这能有帮助。\n环境 Rust 1.70.0 wasm-bindgen 0.2.87 创建项目并添加依赖 此处默认已经安装Rust，需要安装的小伙伴儿可以参考官网。\n使用Cargo创建一个名为hello-wasm的项目：\n1 cargo new --lib hello-wasm 进入项目，打开文件Cargo.toml，添加依赖：\n1 2 3 4 5 [lib] crate-type = [\u0026#34;cdylib\u0026#34;] [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; 更新lib.rs 默认创建项目中，存在一个名为lib.rs的文件，将内容全部替换成：\n1 2 3 4 5 6 use wasm_bindgen::prelude::*; #[wasm_bindgen] pub fn add(a: i32, b: i32) -\u0026gt; i32 { a + b } 编译 至此，我们创建了一个最简单的功能——一个返回两个整数相加结果的函数。\n然后我们可以进行编译了，编译之前需要安装一个工具wasm-pack：\n1 cargo install wasm-pack 然后进行编译：\n1 wasm-pack build --target web 编译完成之后，将会多出来一个pkg文件夹，内容如下：\n1 2 3 4 5 6 pkg ├── hello_wasm.d.ts ├── hello_wasm.js ├── hello_wasm_bg.wasm ├── hello_wasm_bg.wasm.d.ts └── package.json 虽然文件很多，但是首先我们看到了我们所需要的wasm文件，并且，根据go的wasm引入方式，这里我们或许会需要用到js文件。\n前端引入 为了方便最快校验，直接在hello-wasm项目中创建index.html文件，来进行前端引入。\n创建index.html 那么，首先，创建index.html文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;使用Rust和WebAssembly整花活儿\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hello, World! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 是的，没错！这是一场标准的开局！😼\n引入WASM 其实不同于go语言的wasm引入方式，Rust更希望直接引入js文件，而不是让开发者手动引入wasm文件。\n这里使用js引入：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { add } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const result = add(1, 2); console.log(`the result from rust is: ${result}`); } run(); \u0026lt;/script\u0026gt; 完整代码 完整的html代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;使用Rust和WebAssembly整花活儿\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hello, World! \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { add } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const result = add(1, 2); console.log(`the result from rust is: ${result}`); } run(); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 验证 这里可以快速起一个http server，这里我选择使用http-server，也可以使用python3 -m http.server这样的方式，看怎么各自的使用习惯。\n那么，启动http server：\n1 http-server 打开浏览器，访问http://localhost:8080，打开调试器，即可看到输出the result from rust is: 3，这就意味着迈出了整花活儿的第一步！\n常见问题 前端报响应类型错误 详细报错如下：\n1 Failed to load module script: The server responded with a non-JavaScript MIME type of \u0026#34;application/wasm\u0026#34;. Strict MIME type checking is enforced for module scripts per HTML spec. 当引入WebAssembly生成的js文件时，可能会遇到这个报错。报错乍一看是http server的响应问题，或者搜索时候，也会有帖子说这是一个response问题。\n实际上，当按照这个文章一步步操作时是不会有这个问题的，是因为本文的编译参数是直接解决了这个问题的。当我自己摸索的时候，解决这个问题真的是看到人都麻了……\n关键在于编译命令的参数：--target。\n当没有设置这个参数时，默认的参数其实是--target bundler，其是编译成给webpack之类的脚手架使用的。因此这里使用—target web，则是使其编译成可直接在web中使用。\n相关参数如下：\nbundler：编译成给webpack之类的脚手架使用 web：编译成web可直接使用 nodejs：编译成可通过require来加载的node模块 deno：编译成可通过import加载的deno模块 no-modules：跟web类似，但是更旧，且不能使用es模块 直接引入wasm文件 若此时尝试直接引入wasm文件，而不是使用本文所述的方式，那么你会发现，也是可行的！\n1 2 3 4 5 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; WebAssembly.instantiateStreaming(fetch(\u0026#34;./pkg/hello_wasm_bg.wasm\u0026#34;), {}).then( (obj) =\u0026gt; console.log(\u0026#39;the result from rust is: \u0026#39;, obj.instance.exports.add(1, 2)) ); \u0026lt;/script\u0026gt; 是的，没错，当前是可行的，但是当引入了一些别的比如dom之类的，就坏起来了……\n更新的wasm引入方式 上一问题中，且不说是否可以直接引入wasm文件，这里仅说一下，instantiateStreaming这个方法。这是一个更新的方法，无需转成arrayBuffer，这也是摸索Rust整活儿时候发现的。如果在别的语言引入wasm，请使用这个更新的方法吧。\n","date":"2023-06-14T17:32:28Z","image":"https://blog.hunterji.com/p/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E4%B8%80%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/cover_hu822cb824dae9cb9cc6f33de0e5ba4a75_1034399_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.hunterji.com/p/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E4%B8%80%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","title":"使用Rust和WebAssembly整花活儿(一)——快速开始"},{"content":"第三方库的痛苦 在日常的前端开发中，经常需要将一些数据从网页上复制到剪切板中。而实现复制功能，第一时间想到的就是引入第三方库。\n曾经过多不少第三方的剪切板的库，是真的很繁琐，又是创建对象，又是绑定DOM，头都要炸了，就个简单的复制功能，第三方库换来换去地测试\u0026hellip;\u0026hellip;\n后来看到了vueuse可以直接用，突然觉得，哇！真棒！\n直到有一天，搜到了Clipboard api\u0026hellip;\u0026hellip;\n原生支持 官方文档：https://developer.mozilla.org/en-US/docs/Web/API/Clipboard\n不管是读，还是写，统统搞定！而且都还是异步方法。\n比如复制文本到剪切板：\n1 navigator.clipboard.writeText(\u0026#34;\u0026lt;empty clipboard\u0026gt;\u0026#34;) 复制canvas到剪切板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function copyCanvasContentsToClipboard(canvas, onDone, onError) { canvas.toBlob((blob) =\u0026gt; { let data = [new ClipboardItem({ [blob.type]: blob })]; navigator.clipboard.write(data).then( () =\u0026gt; { onDone(); }, (err) =\u0026gt; { onError(err); } ); }); } 读取剪切板的文本：\n1 const txt = navigator.clipboard.readText() ","date":"2023-03-15T22:39:35Z","permalink":"https://blog.hunterji.com/p/%E5%8E%9F%E6%9D%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%94%9F%E6%94%AF%E6%8C%81js%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/","title":"原来浏览器原生支持JS复制到剪切板"},{"content":"前言 前端从后端获取到sts，然后直接minio，极大减少服务端的压力。\n当然，肯定会这种疑问，为什么不在后端生成临时签名url，给前端上传/下载呢？问就是业务需要 /狗头\u0026hellip;\u0026hellip;\n环境 minio: ^7.0.32 typescript: 4.9.5 浏览器上的坑 为什么标题上要强调“浏览器”呢？\n这是因为官方的minio.js，感觉当前版本并没有考虑浏览器的使用场景，无法直接在浏览器上直传。\n所以这里就是推荐一个折中的方案，可以在前端直传。\n当然了，如果业务允许，当前版本请直接在后端生成临时签名url吧！\nminio直传代码实现 安装minio.js 1 pnpm add -D minio 生成client 1 2 3 4 5 6 7 8 9 10 11 import * as Minio from \u0026#39;minio\u0026#39; const minioClient = new Minio.Client({ region: \u0026#39;cn-north-1\u0026#39;, // region字段，极其有必要加上！我在sts场景，不加region字段就报错权限不够/心累... endPoint: \u0026#39;192.168.1.1\u0026#39;, // minio的地址 port: 9000, // minio端口 useSSL: true, // 是否使用ssl accessKey, secretKey, sessionToken, // 可选字段，当为sts时，加入此字段 }) putObject直传方案 1 putObject(bucketName, objectName, stream) 官方提供的putObject方法，必填这三个字段，前两个很好理解，主要是第三个stream，需要详细看一下。\nstream的类型是：string | internal.Readable | Buffer\nstring很好搞定，直接putObject(bucketName, 'hello.txt', 'hello,world!')这样子上传文本文件。\n但是另外两个类型都是nodejs的啊\u0026hellip;啊这\u0026hellip;（也许是我错了，有大佬能够解决的请务必直接告诉我\u0026hellip;）\n折中方案 那么折中的方案就是由前端生成临时签名url，再由前端进行上传 /哭。\n1 const url = await minioClient.presignedPutObject(bucketName, filename) 然后利用http请求url进行上传即可。虽然比较曲折，但是目前相对比较好的前端解决方案。\nhttp请求url上传 此处介绍下http请求上传的相关操作。\n请求上传 请求上传可以有三种方案。\nXMLHttpRequest 1 2 3 4 5 6 7 8 9 10 11 12 const xhrUploadFile = (file: File, url: string) =\u0026gt; { const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;PUT\u0026#39;, url, true); xhr.send(file); xhr.onload = () =\u0026gt; { if (xhr.status === 200) { console.log(`${file.name} 上传成功`); } else { console.error(`${file.name} 上传失败`); } }; } Fetch 1 2 3 4 5 6 7 8 9 10 11 12 const fetchUploadFile = (file: File, url: string) =\u0026gt; { fetch(url, { method: \u0026#39;PUT\u0026#39;, body: file, }) .then((response) =\u0026gt; { console.log(`${file.name} 上传成功`, response); }) .catch((error) =\u0026gt; { console.error(`${file.name} 上传失败`, error); }); } Axios 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const axiosUploadFile = (file: File, url: string) =\u0026gt; { const instance = axios.create(); instance .put(url, file, { headers: { \u0026#39;Content-Type\u0026#39;: file.type, }, }) .then(function (response) { console.log(`${file.name} 上传成功`, response); }) .catch(function (error) { console.error(`${file.name} 上传失败`, error); }); } Promise 此处可以封装一下请求，叠加promisebuff，此处以XMLHttpRequest为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 const uploadRequest = (file: File, url: string) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;PUT\u0026#39;, url, true) xhr.send(file) xhr.onload = () =\u0026gt; { if (xhr.status === 200) resolve(xhr.response) else reject(xhr.status) } }) } 事件响应 要完成上传，怎么能没有响应事件呢。\n此处的事件包括：\n上传进度 上传完成 上传失败 请求代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const uploadRequest = async (file: File, url: string) =\u0026gt; { const xhr = new XMLHttpRequest() xhr.upload.addEventListener(\u0026#39;progress\u0026#39;, (e) =\u0026gt; { onUploadProgress(`${((e.loaded / e.total) * 100).toFixed(0)}`) // 更新进度，此处不保留小数点 }) xhr.onload = () =\u0026gt; { if (xhr.status === 200) { try { onUploaded() // 响应上传完成事件 } catch (error) { onUploadErr((error as Error).message) // 响应上传错误，此处ts处理error } } else { onUploadErr(`http code is ${xhr.status}`) } // 响应上传错误 } xhr.open(\u0026#39;PUT\u0026#39;, url, true) xhr.send(file) } 取消上传 1 2 3 const xhr = new XMLHttpRequest() // ... xhr.abort() // 取消上传 性能优化 对于大文件，或者说需要后台运行的上传任务，可以使用web worker来跑 对于大文件，可以使用切片的方式提高并发，切片的方式也可以实现断点续传，只是需要注意文件切片的顺序和唯一id 参考文档 github.com/minio/minio-js ","date":"2023-02-17T13:31:56Z","permalink":"https://blog.hunterji.com/p/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Ats%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0minio/","title":"浏览器上ts实现前端直传minio"},{"content":"前言 WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。\n快速上手 用go写一个hello world 1 2 3 4 5 6 7 8 9 package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, WebAssembly!\u0026#34;) } 将go文件编译成wasm文件 1 GOOS=js GOARCH=wasm go build -o static/main.wasm 拷贝出wasm_exec.js 该文件为go的wasm的js支持文件\n1 cp \u0026#34;$(go env GOROOT)/misc/wasm/wasm_exec.js\u0026#34; static html文件调用wasm文件 1 2 3 4 5 6 \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; 验证调用 浏览器加载html文件，f12打开控制台，可以看到wasm的打印消息。\ngo与js的类型转换 类型映射 1 2 3 4 5 6 7 8 9 10 | Go | JavaScript | | ---------------------- | ---------------------- | | js.Value | [its value] | | js.Func | function | | nil | null | | bool | boolean | | integers and floats | number | | string | string | | []interface{} | new array | | map[string]interface{} | new object | 如上为官方给出的go与js的类型映射表。\n比如在go中调用js函数，参数为array，那么就可以直接将go的[]interface{}类型的变量作为参数使用。\n函数转换数组 syscall/js提供了两个函数：\nCopyBytesToGo：func CopyBytesToGo(dst []byte, src Value) int CopyBytesToJS：func CopyBytesToJS(dst Value, src []byte) int 两者对于go而言，类型都是[]byte，但是对于js而言，需要Uint8Array或者Uint8ClampedArray类型，否则就会报错。\n那么，如何在go中生成一个Uint8Array或者Uint8ClampedArray类型的变量呢？官方的类型映射表也没有啊\u0026hellip;那么就看下一步。\n其余类型 对于非官方类型映射表内的类型，和官方提供的两个数据类型转换之外的类型，可以通过一种通用的方式来生成，以上一步的Uint8Array为例：\n1 js.Global().Get(\u0026#34;Uint8Array\u0026#34;).New(\u0026lt;length\u0026gt;) 实际使用案例：\n1 2 3 // goData []byte{...} jsData := js.Global().Get(\u0026#34;Uint8Array\u0026#34;).New(len(goData)) js.CopyBytesToJS(jsData, goData) 那么，比如js中的Date类型：\n1 2 dateConstructor := js.Global().Get(\u0026#34;Date\u0026#34;) dateConstructor.New(\u0026#34;2020-10-01\u0026#34;) 极端情况 好吧，还有最后一个方案，如果遇到极端情况，上述方案都无法解决，那么请转换成字符串吧！让go和js用各自的方法分别处理一波，得到自己想要的结果或者给出各自想给的数据。\njs调用go函数 此处需要在go中引入syscall/js，以实现js相关的操作。\n注册go函数 将go的函数注册为js的函数，由js来进行调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;syscall/js\u0026#34; func handleCount(this js.Value, args []js.Value) interface{} { count := args[0].Int() return js.ValueOf(count + 1) } func main() { done := make(chan string, 0) js.Global().Set(\u0026#34;HandleEvent\u0026#34;, js.FuncOf(handleEvent)) \u0026lt;-done } js.Func() 接受一个函数类型作为其参数，该函数的定义是固定的：\n1 2 3 4 func(this Value, args []Value) interface{} // this 即 JavaScript 中的 this // args 是在 JavaScript 中调用该函数的参数列表。 // 返回值需用 js.ValueOf 映射成 JavaScript 的值 js.ValueOf返回作为js的值：\n1 2 3 4 5 6 7 8 9 10 | Go | JavaScript | | ---------------------- | ---------------------- | | js.Value | [its value] | | js.Func | function | | nil | null | | bool | boolean | | integers and floats | number | | string | string | | []interface{} | new array | | map[string]interface{} | new object | js调用 在js中使用也非常简单，引入wasm文件之后，直接调用函数即可。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { HandleEvent(1) // 传入参数1 }) \u0026lt;/script\u0026gt; go调用js函数 如果在js中本身已经定义了函数，那么在go中也可以直接调用该函数，进行运算，将得出的结果在go中继续使用。\n定义js函数 1 2 3 4 5 \u0026lt;script\u0026gt; function add(m, n) { return m + n } \u0026lt;/script\u0026gt; go中调用js函数 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall/js\u0026#34; ) func main() { result := js.Global().Call(\u0026#34;add\u0026#34;, 1, 2) fmt.Println(result) // 此处输出类型为js.Value，无法直接使用 fmt.Println(result.Int() + 1) // 使用.Int()将其转换为go中的类型，即可直接使用 } 引入wasm 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; function add(m, n) { return m + n } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; 结果 在前端调试台可以看到输出：\n1 2 \u0026lt;number: 3\u0026gt; 4 第一个结果就是js.Value的值，第二个结果则是转换成go的值，并按照逻辑进行了+1处理。\n回调函数/解决go函数阻塞问题 The Go function fn is called with the value of JavaScript\u0026rsquo;s \u0026ldquo;this\u0026rdquo; keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.\nInvoking the wrapped Go function from JavaScript will pause the event loop and spawn a new goroutine. Other wrapped functions which are triggered during a call from Go to JavaScript get executed on the same goroutine.\nAs a consequence, if one wrapped function blocks, JavaScript\u0026rsquo;s event loop is blocked until that function returns. Hence, calling any async JavaScript API, which requires the event loop, like fetch (http.Client), will cause an immediate deadlock. Therefore a blocking function should explicitly start a new goroutine.\nsyscall/js官方文档表明，如果go包装函数阻塞，那么js的事件循环也将被阻塞，直到函数返回，调用任何需要事件循环（如fetch）的异步js api都导致立即死锁。因此，一个阻塞函数应该显式地启动一个新的协程。\n此处，可以在go中注册一个回调函数，加上协程实现异步，不会产生堵塞。\n注册函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall/js\u0026#34; \u0026#34;time\u0026#34; ) func handleRender(this js.Value, args []js.Value) interface{} { username := args[0].String() callback := args[len(args)-1] go func() { time.Sleep(3 * time.Second) callback.Invoke(fmt.Sprintf(\u0026#34;hello, %s !\u0026#34;, username)) }() fmt.Println(\u0026#34;waiting...\u0026#34;) return nil } func main() { done := make(chan string, 0) js.Global().Set(\u0026#34;HandleRender\u0026#34;, js.FuncOf(handleRender)) \u0026lt;-done } js调用 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { HandleRender(\u0026#34;tom\u0026#34;, (message) =\u0026gt; console.log(\u0026#39;message: \u0026#39;, message)) }) \u0026lt;/script\u0026gt; 输出 在浏览器调试台，可以看到：\n1 2 waiting... // 先输出了waiting... hello, tom ! // 隔了3秒之后，输出了回调函数的值 Go实现Promise 上一步的回调函数，解决了函数阻塞问题，此处，结合回调函数实现promise，来丰富异步场景。\n在js中，promise是这样的：\n1 2 3 4 5 const message = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;hello, world !\u0026#34;) }, 3000) }) 使用async和await调用，拿到结果：\n1 2 3 4 5 6 7 8 9 10 async function printMessage() { const message = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;hello, world !\u0026#34;) }, 3000) }) const result = await message console.log(result) } 在go中又如何构建promise呢？这里可以用到上述go与js的类型转换，创建一个promise：\n1 js.Global().Get(\u0026#34;Promise\u0026#34;) 注册函数 go的完整实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall/js\u0026#34; \u0026#34;time\u0026#34; ) var document = js.Global().Get(\u0026#34;document\u0026#34;) func handleRender(this js.Value, args []js.Value) interface{} { handler := js.FuncOf(func(this js.Value, args []js.Value) interface{} { resolve := args[0] go func() { time.Sleep(3 * time.Second) resolve.Invoke(\u0026#34;hello, world !\u0026#34;) }() fmt.Println(\u0026#34;waiting...\u0026#34;) return nil }) promiseConstructor := js.Global().Get(\u0026#34;Promise\u0026#34;) return promiseConstructor.New(handler) } func main() { done := make(chan string, 0) js.Global().Set(\u0026#34;HandleRender\u0026#34;, js.FuncOf(handleRender)) \u0026lt;-done } js调用 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, async () =\u0026gt; { const message = await HandleRender() console.log(\u0026#39;message: \u0026#39;, message) }) \u0026lt;/script\u0026gt; 输出 在浏览器调试台，可以看到：\n1 2 waiting... // 先输出了waiting... message: hello, world ! // 隔了3秒之后输出 操作DOM 使用document 定义一个全局的document\n1 var docuemnt = js.Global().Get(\u0026#34;document\u0026#34;) 获取元素 获取一个id为container的div，设置background-color: red、widht: 600、height: 400\n1 2 3 4 5 var containerElement = document.Call(\u0026#34;getElementById\u0026#34;, \u0026#34;container\u0026#34;) var containerElementStyle = container.Get(\u0026#34;style\u0026#34;) containerElementStyle.Set(\u0026#34;background\u0026#34;, \u0026#34;red\u0026#34;) containerElementStyle.Set(\u0026#34;width\u0026#34;, \u0026#34;600px\u0026#34;) containerElementStyle.Set(\u0026#34;height\u0026#34;, \u0026#34;400px\u0026#34;) 创建元素 创建一个id为image的image，设置width:300、height:200\n1 2 3 var imageElement = document.Call(\u0026#34;createElement\u0026#34;, \u0026#34;canvas\u0026#34;) imageElement.Set(\u0026#34;width\u0026#34;, 300) imageElement.Set(\u0026#34;width\u0026#34;, 200) 添加子元素 将image添加为id为container的div的子元素\n1 containerElement.Call(\u0026#34;appendChild\u0026#34;, imageElement) 添加事件 给image添加右击事件，右击image则阻止右键菜单\n1 2 3 4 5 6 7 8 // 定义响应函数 func handlePreventEventCallBack(this js.Value, args []js.Value) interface{} { args[0].Call(\u0026#34;preventDefault\u0026#34;) return false } // 给image添加事件 imageElement.Call(\u0026#34;addEventListener\u0026#34;, \u0026#34;contextmenu\u0026#34;, js.FuncOf(handlePreventEventCallBack)) 这里需要注意的是，当不再调用响应事件函数时，必须调用Func.Release以释放资源：\n1 2 3 4 5 6 7 var cb js.Func cb = js.FuncOf(func(this js.Value, args []js.Value) any { fmt.Println(\u0026#34;button clicked\u0026#34;) cb.Release() // 如果不再单击该按钮，则释放该函数 return nil }) js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, \u0026#34;myButton\u0026#34;).Call(\u0026#34;addEventListener\u0026#34;, \u0026#34;click\u0026#34;, cb) Canvas 这里放一波canvas的案例，包含了一些常用方法，可以参考完成更多操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import ( \u0026#34;math\u0026#34; \u0026#34;syscall/js\u0026#34; ) const ( width = 400 height = 400 radius = 200 ) var document = js.Global().Get(\u0026#34;document\u0026#34;) func handleRender(this js.Value, args []js.Value) interface{} { var canvas = document.Call(\u0026#34;getElementById\u0026#34;, \u0026#34;canvas\u0026#34;) canvas.Set(\u0026#34;width\u0026#34;, width) canvas.Set(\u0026#34;height\u0026#34;, height) var ctx = canvas.Call(\u0026#34;getContext\u0026#34;, \u0026#34;2d\u0026#34;) ctx.Call(\u0026#34;beginPath\u0026#34;) ctx.Call(\u0026#34;arc\u0026#34;, width/2, height/2, radius, 0, 2*math.Pi) ctx.Set(\u0026#34;fillStyle\u0026#34;, \u0026#34;lightpink\u0026#34;) ctx.Call(\u0026#34;fill\u0026#34;) ctx.Set(\u0026#34;lineWidth\u0026#34;, 2) ctx.Set(\u0026#34;strokeStyle\u0026#34;, \u0026#34;red\u0026#34;) ctx.Call(\u0026#34;stroke\u0026#34;) ctx.Set(\u0026#34;font\u0026#34;, \u0026#34;20px Comic Sans MS\u0026#34;) ctx.Set(\u0026#34;fillStyle\u0026#34;, \u0026#34;blue\u0026#34;) ctx.Call(\u0026#34;fillText\u0026#34;, \u0026#34;Hello, World !\u0026#34;, width/2-60, height/2) return nil } func main() { done := make(chan string, 0) js.Global().Set(\u0026#34;HandleRender\u0026#34;, js.FuncOf(handleRender)) \u0026lt;-done } 渲染结果：\n参考文档 syscall/js go wiki WebAssembly Go WebAssembly (Wasm) 简明教程 Go, WebAssembly, HTTP requests and Promises ","date":"2023-02-09T13:15:34Z","image":"https://blog.hunterji.com/p/webassembly--%E6%9C%AA%E6%9D%A5%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/cover_hu18c5fb7037479757471f623d2395d33e_660360_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.hunterji.com/p/webassembly--%E6%9C%AA%E6%9D%A5%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/","title":"WebAssembly -- 未来前端开发的必备技能"},{"content":"环境 vue 3.2 typescript 4.7.4 wow.js 1.2.2 animate.css 4.1.1 animate.css 下载 1 pnpm add animate.css -D 引入 在vue3项目的main.ts中引入\n1 import \u0026#39;animate.css\u0026#39; 使用 需要注意的是，animate css在4.0之后使用animate__前缀\n1 \u0026lt;h1 class=\u0026#34;animate__animated animate__bounce\u0026#34;\u0026gt;An animated element\u0026lt;/h1\u0026gt; 动画延迟 官方方法 官方给出的动画延迟是animate__delay-2s、animate__delay-3s \u0026hellip;\u0026hellip;\n直接在class中添加即可\n1 \u0026lt;h1 class=\u0026#34;animate__animated animate__bounce animate__delay-2s\u0026#34;\u0026gt;An animated element\u0026lt;/h1\u0026gt; 自定义延迟 特殊场景需要使用不同于官方的延迟时间，因此可以自定义延迟时间，直接声明延迟的类，然后在class上加入即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .animation-delay-1 { animation-delay: 100ms; } .animation-delay-2 { animation-delay: 300ms; } .animation-delay-3 { animation-delay: 500ms; } .animation-delay-4 { animation-delay: 700ms; } .animation-delay-5 { animation-delay: 900ms; } 使用\n1 2 \u0026lt;h1 class=\u0026#34;animate__animated animate__bounce animation-delay-1\u0026#34;\u0026gt;An animated element\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;animate__animated animate__bounce animation-delay-2\u0026#34;\u0026gt;Another animated element\u0026lt;/h1\u0026gt; wow.js 下载 1 pnpm add wow.js -D 引入 在vue3项目的main.ts中引入，内容如下:\n1 2 3 4 5 6 7 8 9 import WOW from \u0026#39;wow.js\u0026#39; new WOW({ boxClass: \u0026#39;wow\u0026#39;, // 类名，在用户滚动时显示隐藏的框。 animateClass: \u0026#39;animate__animated\u0026#39;, // 触发CSS动画的类名称 offset: 300, // 定义浏览器视口底部与隐藏框顶部之间的距离。当用户滚动并到达此距离时，隐藏的框会显示出来。 mobile: true, // 在移动设备上打开/关闭WOW.js。 live: true, // 在页面上同时检查新的WOW元素。 }).init() 使用 使用wow直接替代animate__animated即可\n1 \u0026lt;h1 class=\u0026#34;wow animate__bounce animation-delay-1\u0026#34;\u0026gt;An animated element\u0026lt;/h1\u0026gt; 结语 由于写一个页面需要使用到wow，好多年没用过了，查了一下文档超多版本教程，使用起来各种不成功，难受\u0026hellip;暂时也没找到可替代的方案\u0026hellip;\n参考文档 wow animate css ","date":"2023-01-28T16:09:44Z","permalink":"https://blog.hunterji.com/p/wow.js%E5%92%8Canimate-css%E5%9C%A8vue3%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","title":"wow.js和animate css在vue3中的应用"},{"content":"socket tcp server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import socket def socket_tcp_server(server_ip: str = \u0026#39;0.0.0.0\u0026#39;, server_port: int = 9000, buffer_size: int = 1024): \u0026#34;\u0026#34;\u0026#34; socket tcp 服务端 :param server_ip: 服务器的地址, 默认为0.0.0.0, 表示允许所有 :param server_port: 服务器tcp server接收信息的端口, 默认9000 :param buffer_size: 套接字缓冲区大小, 默认1024 :return: none \u0026#34;\u0026#34;\u0026#34; tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) tcp_socket.bind((server_ip, server_port)) tcp_socket.listen(128) print(\u0026#39;服务端开始运行...\\n\u0026#39;) while True: client, sender_info = tcp_socket.accept() receive_data = client.recv(buffer_size) print(\u0026#39;客户端地址: {}\u0026#39;.format(sender_info)) print(\u0026#39;来自客户端的信息: {}\u0026#39;.format(receive_data.decode(\u0026#39;utf-8\u0026#39;))) # 返回消息 client.send(str.encode(\u0026#39;response...\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: socket_tcp_server() socket tcp client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import socket def socket_tcp_client_send_message(message: str, server_ip: str, server_port: int, buffer_size: int = 1024): \u0026#34;\u0026#34;\u0026#34; socket tcp 客户端发送消息 :param message: 消息 :param server_ip: 服务端的ip地址 :param server_port: 服务端的端口号 :return: none \u0026#34;\u0026#34;\u0026#34; tcp_client_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM) tcp_client_socket.connect((server_ip, server_port)) tcp_client_socket.send(str.encode(message)) response = tcp_client_socket.recv(buffer_size) print(\u0026#39;response : {}\u0026#39;.format(response.decode())) tcp_client_socket.close() if __name__ == \u0026#39;__main__\u0026#39;: socket_tcp_client_send_message(\u0026#39;hello,world!\u0026#39;, \u0026#39;127.0.0.1\u0026#39;, 9000) ","date":"2022-06-09T22:57:54Z","permalink":"https://blog.hunterji.com/p/python3-socket-tcp-example/","title":"python3 socket tcp example"},{"content":"socket udp server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import socket def socket_udp_server(server_ip: str = \u0026#39;0.0.0.0\u0026#39;, server_port: int = 9000, buffer_size: int = 1024): \u0026#34;\u0026#34;\u0026#34; socket udp 服务端 :param server_ip: 服务器的地址, 默认为0.0.0.0, 表示允许所有 :param server_port: 服务器udp server接收信息的端口, 默认9000 :param buffer_size: 套接字缓冲区大小, 默认1024 :return: none \u0026#34;\u0026#34;\u0026#34; udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((server_ip, server_port)) print(\u0026#39;服务端开始运行...\\n\u0026#39;) while True: receive_data, sender_info = udp_socket.recvfrom(buffer_size) print(\u0026#39;客户端地址: {}\u0026#39;.format(sender_info)) print(\u0026#39;来自客户端的信息: {}\u0026#39;.format(receive_data.decode(\u0026#39;utf-8\u0026#39;))) if __name__ == \u0026#39;__main__\u0026#39;: socket_udp_server() socket udp client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import socket def socket_udp_client_send_message(message: str, server_ip: str, server_port: int): \u0026#34;\u0026#34;\u0026#34; socket udp 客户端发送消息 :param message: 消息 :param server_ip: 服务端的ip地址 :param server_port: 服务端的端口号 :return: none \u0026#34;\u0026#34;\u0026#34; udp_client_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM) udp_client_socket.sendto(str.encode(message), (server_ip, server_port)) if __name__ == \u0026#39;__main__\u0026#39;: socket_udp_client_send_message(\u0026#39;hello,world!\u0026#39;, \u0026#39;127.0.0.1\u0026#39;, 9000) ","date":"2022-06-09T22:57:54Z","permalink":"https://blog.hunterji.com/p/python3-socket-udp-example/","title":"python3 socket udp example"},{"content":"前言 基于架构的调整，前端开始转为微前端。经过调研，决定使用qiankun微服务框架来使用，本文将介绍VUE3+TS+qiankun的实践经过。微服务架构的优势之一在于可以结合不同技术栈的节点，基于技术栈的考虑，此处用的都是vue3。\n源码：https://github.com/Kuari/Blog/tree/master/Examples/microFrontend\n环境 vue 3.0.0 TypeScript 4.1.5 vue router 4.0.0 @vue/cli 4.5.15 qiankun 2.6.3 实践 架构 如上图所示，微服务架构将会由多个节点构成，首先由一个主节点site_base连接所有子节点，子节点可以不断拓展。\n主节点 主节点源码可见于https://github.com/Kuari/Blog/tree/master/Examples/microFrontend/site_base\n创建主节点，选择vue3+ts\n1 2 vue create site_base cd site_base 安装qiankun\n1 yarn add qiankun 在src/App.vue中添加路由和渲染节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;nav\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; | \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; | \u0026lt;!-- 新增site1路由 --\u0026gt; \u0026lt;router-link to=\u0026#34;/site1\u0026#34;\u0026gt;Site1\u0026lt;/router-link\u0026gt; | \u0026lt;!-- 新增site2路由 --\u0026gt; \u0026lt;router-link to=\u0026#34;/site2\u0026#34;\u0026gt;Site2\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;!-- 新增site1渲染节点 --\u0026gt; \u0026lt;div id=\u0026#34;site1\u0026#34; /\u0026gt; \u0026lt;!-- 新增site2渲染节点 --\u0026gt; \u0026lt;div id=\u0026#34;site2\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 在src/main.ts中引入子节点配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import { registerMicroApps, start } from \u0026#39;qiankun\u0026#39; const apps: any[] = [ { name: \u0026#39;site1\u0026#39;, // 应用的名字 entry: \u0026#39;http://localhost:9001/\u0026#39;, // 默认加载这个html，解析里面的js动态的执行（子应用必须支持跨域，内部使用的是 fetch） container: \u0026#39;#site1\u0026#39;, // 要渲染到的节点id，对应上一步中src/App.vue中的渲染节点 activeRule: \u0026#39;/site1\u0026#39; // 访问子节点路由 }, { name: \u0026#39;site2\u0026#39;, entry: \u0026#39;http://localhost:9002/\u0026#39;, container: \u0026#39;#site2\u0026#39;, activeRule: \u0026#39;/site2\u0026#39; } ] registerMicroApps(apps) // 注册应用 start() // 开启应用 createApp(App).use(store).use(router).mount(\u0026#39;#app\u0026#39;) 子节点 子节点源码可见于https://github.com/Kuari/Blog/tree/master/Examples/microFrontend/site_1\n此处以site1为例，site2同理。\n创建子节点，选择vue3+ts\n1 2 vue create site_1 cd site_1 编辑src/App.vue\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;router-view /\u0026gt; \u0026lt;/template\u0026gt; 编辑src/views/Home.vue，修改其内容，写一点标识性的文本\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;Hello, Site1!\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 创建文件src/pulic-path.ts，第一行的注视一定要加，避免eslint对于变量的报错\n1 2 3 4 /* eslint-disable camelcase */ if ((window as any).__POWERED_BY_QIANKUN__) { __webpack_public_path__ = (window as any).__INJECTED_PUBLIC_PATH_BY_QIANKUN__ } 编辑src/router/index.ts，此处直接返回routes，而不是router，并且修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { RouteRecordRaw } from \u0026#39;vue-router\u0026#39; const routes: Array\u0026lt;RouteRecordRaw\u0026gt; = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/Home.vue\u0026#39;) }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;About\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/About.vue\u0026#39;) } ] // 直接返回routes，由其它地方处理创建路由 export default routes 编辑src/main.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import \u0026#39;./public-path\u0026#39; import { createApp } from \u0026#39;vue\u0026#39; import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import routes from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; let router = null let instance: any = null let history: any = null function render (props = {}) { const { container } = props // 当为微服务主节点情况下访问，会设置二级路径，而直接访问时没有二级路径，此处需要根据实际情况修改 history = createWebHistory(window.__POWERED_BY_QIANKUN__ ? \u0026#39;/site1\u0026#39; : \u0026#39;/\u0026#39;) router = createRouter({ history, routes }) instance = createApp(App) instance.use(router) instance.use(store) instance.mount(container ? container.querySelector(\u0026#39;#app\u0026#39;) : \u0026#39;#app\u0026#39;) } if (!window.__POWERED_BY_QIANKUN__) { render() } export const bootstrap = async (): Promise\u0026lt;void\u0026gt; =\u0026gt; { console.log(\u0026#39;%c \u0026#39;, \u0026#39;color: green \u0026#39;, \u0026#39;vue3.0 app bootstraped\u0026#39;) } const storeTest = (props: any): void =\u0026gt; { props.onGlobalStateChange \u0026amp;\u0026amp; props.onGlobalStateChange( (value, prev) =\u0026gt; console.log(`[onGlobalStateChange - ${props.name}]:`, value, prev), true ) props.setGlobalState \u0026amp;\u0026amp; props.setGlobalState({ ignore: props.name, user: { name: props.name } }) } export const mount = async (props: any): Promise\u0026lt;void\u0026gt; =\u0026gt; { storeTest(props) render(props) instance.config.globalProperties.$onGlobalStateChange = props.onGlobalStateChange instance.config.globalProperties.$setGlobalState = props.setGlobalState } export const unmount = async (): Promise\u0026lt;void\u0026gt; =\u0026gt; { instance.unmount() instance._container.innerHTML = \u0026#39;\u0026#39; instance = null router = null history.destroy() } 创建文件vue.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const path = require(\u0026#39;path\u0026#39;) const { name } = require(\u0026#39;./package\u0026#39;) function resolve (dir) { return path.join(__dirname, dir) } const port = 9001 module.exports = { outputDir: \u0026#39;dist\u0026#39;, assetsDir: \u0026#39;static\u0026#39;, filenameHashing: true, devServer: { hot: true, disableHostCheck: true, port, overlay: { warnings: false, errors: true }, headers: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39; } }, // 自定义webpack配置 configureWebpack: { resolve: { alias: { \u0026#39;@\u0026#39;: resolve(\u0026#39;src\u0026#39;) } }, output: { // 把子应用打包成 umd 库格式 library: `${name}-[name]`, libraryTarget: \u0026#39;umd\u0026#39;, jsonpFunction: `webpackJsonp_${name}` } } } 验证 主节点和子节点分别独立运行，但是子节点的地址需要跟主节点配置中子节点对应的地址相同。\n在主节点上点击子节点的路由，即可在主节点上访问子节点的页面了！\n主节点优化 主节点除了如上配置，可以进行两项优化：\n模块化子节点配置 添加过渡状态，当加载子节点时窗口顶部出现加载进度条 优化后主节点源码可见于https://github.com/Kuari/Blog/tree/master/Examples/microFrontend/site_base_optimize\n模块化子节点配置 创建文件夹src/childNodes，然后创建文件src/childNodes/apps.ts\n1 2 3 4 5 6 7 8 9 10 const apps: any[] = [ { name: \u0026#39;site1\u0026#39;, // 应用的名字 entry: \u0026#39;http://localhost:9001/\u0026#39;, // 默认加载这个html，解析里面的js动态的执行（子应用必须支持跨域，内部使用的是 fetch） container: \u0026#39;#site1\u0026#39;, // 要渲染到的节点id activeRule: \u0026#39;/site1\u0026#39; // 访问子节点路由 } ] export default apps 创建文件src/childNodes/index.ts\n1 2 3 4 5 6 import { registerMicroApps, start } from \u0026#39;qiankun\u0026#39; import apps from \u0026#39;./apps\u0026#39; registerMicroApps(apps) export default start 编辑src/main.ts\n1 2 3 4 5 6 7 8 9 import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import start from \u0026#39;./childNodes\u0026#39; start() // 开启应用 createApp(App).use(store).use(router).mount(\u0026#39;#app\u0026#39;) 过渡效果 此处的过渡效果采用NProgress库，先来安装一波\n1 yarn add nprogress 编辑src/childNodes/index.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { addGlobalUncaughtErrorHandler, registerMicroApps, start } from \u0026#39;qiankun\u0026#39; import apps from \u0026#39;./apps\u0026#39; import NProgress from \u0026#39;nprogress\u0026#39; import \u0026#39;nprogress/nprogress.css\u0026#39; registerMicroApps(apps, { // qiankun 生命周期钩子 - 子节点加载前 beforeLoad: (app: any) =\u0026gt; { NProgress.start() // 开始进度条 return Promise.resolve() }, // qiankun 生命周期钩子 - 子节点挂载后 afterMount: (app: any) =\u0026gt; { NProgress.done() // 进度条结束 return Promise.resolve() } }) export default start 结语 qiankun框架确实挺不错的，配置也并不是复杂，但是唯一想吐槽的一点是对于ts的支持感觉不太好/狗头，或许是我写得不够好吧，后面会持续优化使用。\n参考文档 qiankun官方文档 vue3+ts+qiankun的微前端快速上手 ","date":"2022-02-16T15:07:56Z","permalink":"https://blog.hunterji.com/p/vue3-ts-%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/","title":"VUE3+TS+微前端实践"},{"content":"前言 i18n是“国际化”的简称。在资讯领域，国际化(i18n)指让产品（出版物，软件，硬件等）无需做大的改变就能够适应不同的语言和地区的需要。对程序来说，在不修改内部代码的情况下，能根据不同语言及地区显示相应的界面。 在全球化的时代，国际化尤为重要，因为产品的潜在用户可能来自世界的各个角落。\nNode.js本身有一个i18n的包，但是为了更好地结合vue，此处我们使用的是vue-i18n。\n源码：https://github.com/Kuari/Blog/tree/master/Examples/vue_i18n_demo\n环境 Vue 3.0.0 TypeScript 4.5.4 Vue Cli 4.5.15 安装 使用vue cli安装，会自动生成文件且引入。\n1 vue add i18n 执行过程中将需要填写如下问题：\n1 2 3 4 ? The locale of project localization. [默认选项]en ? The fallback locale of project localization. [默认选项]en ? The directory where store localization messages of project. It\u0026#39;s stored under `src` directory. [默认选项]locales ? Enable legacy API (compatible vue-i18n@v8.x) mode ? [默认选项]No 执行完成之后，将会自动处理如下文件：\n1 2 3 4 5 6 7 8 9 10 // vue add i18n执行结束后的git status new file: .env // 执行过程中的第一个和第二个问题将使用环境变量更新 modified: package.json new file: src/components/HelloI18n.vue // 官方给出的demo组件 new file: src/i18n.ts // 自动读取多语言的json文件且创建i18n实例 new file: src/locales/en.json // 多语言json文件所在文件夹，默认选择的en语言，所以生成一个默认的语言json文件 modified: src/main.ts // 引入i18n new file: vue.config.js // 配置i18n modified: yarn.lock 多语言配置 想要多语言则需要配置多个对应语言的json文件，其字段必须相同，否则当用户切换时，会出现找不到该字段对应文字的问题。\n为了便于切换和处理，此处不再使用en之类的简写，而是和系统语言名称对应起来，此处将使用zh_CN和en_GB来做配置。\n创建多语言json文件 此处生成两个文件src/locales/zh_CN.json和src/locales/en_GB.json，内容分别如下：\n1 2 3 4 { \u0026#34;language\u0026#34;: \u0026#34;中文\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;你好，世界!\u0026#34; } 1 2 3 4 { \u0026#34;language\u0026#34;: \u0026#34;English\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Hello, World !\u0026#34; } 更新语言标识 将相关文件的en都改成en_GB。\n1 2 3 4 ##env VUE_APP_I18N_LOCALE=en_GB VUE_APP_I18N_FALLBACK_LOCALE=en_GB 1 2 3 4 5 6 7 8 9 // src/i18n.ts // ... export default createI18n({ legacy: false, locale: process.env.VUE_APP_I18N_LOCALE || \u0026#39;en_GB\u0026#39;, fallbackLocale: process.env.VUE_APP_I18N_FALLBACK_LOCALE || \u0026#39;en_GB\u0026#39;, messages: loadLocaleMessages() }) 使用 重写首页 此处重写src/views/Home.vue文件，先按照正常的内容去写，内容如下：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;Hello, World !\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 配置多语言 需要配置多语言的地方就是展示的文字，所以将该文字替换掉即可。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ t(\u0026#39;message\u0026#39;) }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { t } = useI18n() \u0026lt;/script\u0026gt; 此处引入t方法，而其参数message为上面配置的每一个json文件中的message字段，其将用json对应字段的value来展示。\n可能有小伙伴儿要问，那如果不是html中的展示文字怎么办呢？\n这也一样使用t方法的，示例如下：\n1 \u0026lt;input type=\u0026#34;text\u0026#34; :placeholder=\u0026#34;t(\u0026#39;message\u0026#39;)\u0026#34; /\u0026gt; 1 2 3 4 5 6 7 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { t } = useI18n() const exampleVal = t(\u0026#39;message\u0026#39;) \u0026lt;/script\u0026gt; 此处我们的json结构都是单层的，如果是嵌套的结构的话，可以使用t('home.message')这样的方式来引用。\n切换语言 此处需要引入locale，主要通过更新locale.value来切换语言。此处的切换是全局的，所以只需要写一个切换组件，其它组件都将会被切换语言。\n写一个下拉框来实现语言的切换，完整内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ t(\u0026#39;message\u0026#39;) }}\u0026lt;/div\u0026gt; \u0026lt;select v-model=\u0026#34;state.language\u0026#34; @change=\u0026#34;handleLanguageChange\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;zh_CN\u0026#34;\u0026gt;zh_CN\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;en_GB\u0026#34;\u0026gt;en_GB\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { reactive } from \u0026#39;vue\u0026#39; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { t, locale } = useI18n() const state: { language: string } = reactive({ language: \u0026#39;en_GB\u0026#39; }) const handleLanguageChange = (option: { target: { value: string } }) =\u0026gt; { // 主要通过更新locale.value来切换语言 locale.value = option.target.value } \u0026lt;/script\u0026gt; 通过下拉框切换选项可以切换语言。\n本地环境 虽然i18n设置了默认的语言，但是友好的交互应当是根据用户的环境语言加载。这里需要使用navigator.language来拿到用户的环境语言，通过判断环境语言切换初始的语言配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 switch (navigator.language) { case \u0026#39;zh-CN\u0026#39;: state.language = \u0026#39;zh_CN\u0026#39; locale.value = \u0026#39;zh_CN\u0026#39; break case \u0026#39;en-GB\u0026#39;: state.language = \u0026#39;en_GB\u0026#39; locale.value = \u0026#39;en_GB\u0026#39; break default: state.language = \u0026#39;en_GB\u0026#39; locale.value = \u0026#39;en_GB\u0026#39; } 完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ t(\u0026#39;message\u0026#39;) }}\u0026lt;/div\u0026gt; \u0026lt;select v-model=\u0026#34;state.language\u0026#34; @change=\u0026#34;handleLanguageChange\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;zh_CN\u0026#34;\u0026gt;zh_CN\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;en_GB\u0026#34;\u0026gt;en_GB\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { reactive, onMounted } from \u0026#39;vue\u0026#39; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { t, locale } = useI18n() const state: { language: string } = reactive({ language: \u0026#39;en_GB\u0026#39; }) const handleLanguageChange = (option: { target: { value: string } }) =\u0026gt; { // 主要通过更新locale.value来切换语言 locale.value = option.target.value } const fetchData = () =\u0026gt; { switch (navigator.language) { // 环境语言中间的线是居中的 case \u0026#39;zh-CN\u0026#39;: state.language = \u0026#39;zh_CN\u0026#39; locale.value = \u0026#39;zh_CN\u0026#39; break case \u0026#39;en-GB\u0026#39;: state.language = \u0026#39;en_GB\u0026#39; locale.value = \u0026#39;en_GB\u0026#39; break default: state.language = \u0026#39;en_GB\u0026#39; locale.value = \u0026#39;en_GB\u0026#39; } } onMounted(() =\u0026gt; { fetchData() }) \u0026lt;/script\u0026gt; 运行之后，默认语言不再是英语，而是跟环境语言一致的。\n参考文档 vue-i18n ","date":"2021-12-29T14:24:30Z","permalink":"https://blog.hunterji.com/p/vue%E9%A1%B9%E7%9B%AE%E5%9B%BD%E9%99%85%E5%8C%96/","title":"VUE项目国际化"},{"content":"报错 在使用vue cli plugin electron builder开发项目，用到涉及node相关的功能，比如fs、path，出现报错__dirname not defined 。\n解决 该问题在于需要开启electron对于node操作的支持。\n安装@types/node 1 yarn add @types/node -D 修改配置 修改electron的配置文件，此处我的配置文件为src/background.ts\n1 2 3 4 5 webPreferences: { // ... nodeIntegration: true, nodeIntegrationInWorker: true } ","date":"2021-11-29T17:29:14Z","permalink":"https://blog.hunterji.com/p/electron%E7%9A%84__dirname-not-defined%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","title":"electron的__dirname not defined报错解决"},{"content":"报错 在使用vue3+typescript+electron开发时，遇到一个报错为：\n1 Uncaught ReferenceError: require is not defined 点进去是module.exports = require(\u0026quot;events\u0026quot;)，并不是自己的代码中的require，因此无法改变写法只能让项目去支持它。\n解决 在electron的配置文件中，新增或者修改如下配置：\n1 2 3 4 5 webPreferences: { // ... contextIsolation: false, nodeIntegration: true } 参考文档 Electron/Tedious: require(\u0026ldquo;events\u0026rdquo;) is not defined ","date":"2021-11-29T17:23:46Z","permalink":"https://blog.hunterji.com/p/vue3-ts-electron%E4%B8%8D%E6%94%AF%E6%8C%81require-is-not-defined%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","title":"vue3+ts+electron不支持require is not defined报错解决"},{"content":"前言 最近在用uniapp开发小程序，需要用到canvas画海报然后再保存本地。\n之前写过同样功能的文章，不过场景不同，之前是在web上生成海报，该场景可以使用之前文章的方法——html转canvas来实现。\n但是uniapp则不同，该框架是去DOM化的，因此只能使用uniapp的官方canvas来实现。\n功能拆解 网上找到的文章，有几篇写得挺好的，展现了完整的功能。这里我把用到的几个功能拆解出来，而不用先通读整篇代码。\n创建canvas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;view\u0026gt; \u0026lt;canvas style=\u0026#34;width: 300px; height: 200px;\u0026#34; canvas-id=\u0026#34;firstCanvas\u0026#34; id=\u0026#34;firstCanvas\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { onReady() { // 初始化 const ctx = uni.createCanvasContext(\u0026#39;firstCanvas\u0026#39;) // 将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中 ctx.draw() } } \u0026lt;/script\u0026gt; 背景色 1 2 3 ctx.setFillStyle(\u0026#39;red\u0026#39;) ctx.fillRect(0, 0, 300, 200) // 此处其实绘制了一个300x200的红色矩形，但是其大小跟canvas大小相同即为背景色了 加载图片 1）本地图片 图片直接在项目中，可以直接加载。\n1 ctx.drawImage(\u0026#34;./background.png\u0026#34;, 0, 0, 300, 200) 2）url 此处url返回的为文件流，在uniapp中无法直接加载，需要转换成本地信息才可以使用。\n有两种方式可以使用，小程序都需要添加download合法域名：\nuni.getImageInfo：获取文件信息，我使用的这个方法 uni.downloadFile：下载文件 原生使用方法是这样的：\n1 2 3 4 5 6 uni.getImageInfo({ src: url, success: (res) =\u0026gt; { ctx.drawImage(res.path, 0, 0, 300, 200) } }) 由于js的异步问题，如果图片较大或者多个图片的情况下，会有这边还没加载完，canvas就已经绘制完了的情况，所以这里将其优化下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 首先封装 const getImageInfo = (url: string): Promise\u0026lt;string\u0026gt; =\u0026gt; { return new Promise((req, rej) =\u0026gt; { uni.getImageInfo({ src: url, success: (res) =\u0026gt; { req(res.path) } }) }) } // 调用 const genPoster = async() =\u0026gt; { const imgPath = await getImageInfo(\u0026lt;your-url\u0026gt;) // 建议所有图片在开始绘制canvas前加载好 const ctx = uni.createCanvasContext(\u0026#39;firstCanvas\u0026#39;) ctx.drawImage(imgPath, 0, 0, 300, 200) ctx.draw() } 3）base64 如果你的图片数据是base64的，那恭喜你，依然加载不了。当然这存在的情况是，微信开发工具是没有问题的，但是上了真机之后直接无法加载了，这波是小程序的锅。\n这里呢需要将图片存储然后用本地地址绘制。\n原生方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 const fs = wx.getFileSystemManager() let times = new Date().getTime() let codeImg = wx.env.USER_DATA_PATH + \u0026#39;/\u0026#39; + times + \u0026#39;.png\u0026#39; return new Promise((req, rej) =\u0026gt; { fs.writeFile({ filePath: imgPath, data: \u0026lt;your-base64-data\u0026gt;, encoding: \u0026#39;base64\u0026#39;, success: () =\u0026gt; { ctx.drawImage(imgPath, 0, 0, 300, 200) } }) }) 优化一波：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 封装 const getBase64ImageInfo = (base64Data: string): Promise\u0026lt;string\u0026gt; =\u0026gt; { const fs = wx.getFileSystemManager() let times = new Date().getTime() let codeImg = wx.env.USER_DATA_PATH + \u0026#39;/\u0026#39; + times + \u0026#39;.png\u0026#39; return new Promise((req, rej) =\u0026gt; { fs.writeFile({ filePath: imgPath, data: base64Data, encoding: \u0026#39;base64\u0026#39;, success: () =\u0026gt; { req(imgPath) } }) }) } // 调用 const genPoster = async() =\u0026gt; { const imgPath = await getBase64ImageInfo(\u0026lt;your-base64-data\u0026gt;) // 建议所有图片在开始绘制canvas前加载好 const ctx = uni.createCanvasContext(\u0026#39;firstCanvas\u0026#39;) ctx.drawImage(imgPath, 0, 0, 300, 200) ctx.draw() } 文字 1 2 3 4 ctx.setFontSize(13) ctx.font = \u0026#34;nomarl bold 13px Arial,sans-serif\u0026#34; // 加粗等功能 ctx.setFillStyle(\u0026#39;#ffffff\u0026#39;) ctx.fillText(\u0026#34;hello, world !\u0026#34;, 16, 16) 圆角矩形 想要绘制一个圆角的矩形，啊\u0026hellip;\u0026hellip;这波就复杂了，原理就不细讲了，直接上代码，调用即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const roundedRect = (x: number, y: number, width: number, height: number, radius: number) =\u0026gt; { if (width \u0026lt;= 0 || height \u0026lt;= 0) { ctx.arc(x, y, radius, 0, Math.PI * 2); return; } ctx.moveTo(x + radius, y); ctx.arcTo(x + width, y, x + width, y + height, radius); ctx.arcTo(x + width, y + height, x, y + height, radius); ctx.arcTo(x, y + height, x, y, radius); ctx.arcTo(x, y, x + radius, y, radius); } const drawRoundedRect = (strokeStyle: string, fillStyle: string, x: number, y: number, width: number, height: number, radius: number) =\u0026gt; { ctx.beginPath(); roundedRect(x, y, width, height, radius); ctx.strokeStyle = strokeStyle; ctx.fillStyle = fillStyle; ctx.stroke(); ctx.fill(); } // 调用 drawRoundedRect(\u0026#39;#ffffff\u0026#39;, \u0026#39;#ffffff\u0026#39;, 16, 16, 86, 6) 图片加载为圆形 基本原理是，正常加载图片，canvas画个圆给它裁剪掉，上代码！\n1 2 3 4 5 6 7 8 9 ctx.save() ctx.beginPath() ctx.arc(16, 16, 12, 0, 2 * Math.PI) // 如果小伙伴儿调试时候感觉圆形和图片有点错位，可以开启下面两行注释代码，给圆圈加个边框 // ctx.setStrokeStyle(\u0026#39;#AAAAAA\u0026#39;) // ctx.stroke() ctx.clip() ctx.drawImage(\u0026lt;your-image-path\u0026gt;, 16, 16, 24, 24) ctx.restore() canvas生成的海报下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const savePoster = () =\u0026gt; { uni.showModal({ title: \u0026#39;提示\u0026#39;, content: \u0026#39;确定保存到相册吗\u0026#39;, success: (response) =\u0026gt; { uni.canvasToTempFilePath({ canvasId: \u0026#39;sharePoster\u0026#39;, success: (response) =\u0026gt; { uni.saveImageToPhotosAlbum({ filePath: response.tempFilePath, success: (response) =\u0026gt; { console.log(response); // 此处为执行成功 // ... }, fail: (response) =\u0026gt; { uni.openSetting({ success: (response) =\u0026gt; { if (!response.authSetting[\u0026#39;scope.writePhotosAlbum\u0026#39;]) { uni.showModal({ title: \u0026#39;提示\u0026#39;, content: \u0026#39;获取权限成功，再次点击图片即可保存\u0026#39;, showCancel: false }) } else { uni.showModal({ title: \u0026#39;提示\u0026#39;, content: \u0026#39;获取权限失败，无法保存\u0026#39;, showCancel: false }) } } }) } }) }, fail: (response) =\u0026gt; { console.log(response); } }, this); } }) } 问题 图片有时显示有时不显示 1 参照本文“二.3.加载图片”优化代码处，将加载图片全部写成同步的，在开始绘制前将图片全都加载好。 base64数据的图片在小程序开发工具显示，到了真机就不显示了 1 参照本文“二.3.3）base64”优化代码处，使用该方法即可。小程序canvas无法直接加载base64图片。 canvas整体画成圆角的 1 canvas背景是透明色，只要画个大小覆盖canvas的圆角矩形或者使用圆角背景图即可。 ","date":"2021-11-25T17:07:55Z","permalink":"https://blog.hunterji.com/p/uniapp-canvas%E7%94%9F%E6%88%90%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E6%8B%86%E8%A7%A3%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"uniapp canvas生成海报功能拆解和问题记录"},{"content":"问题 功能开发过程中写遮罩时，遇到遮罩下页面还可以滚动的问题。\n解决 直接给遮罩下的元素套上一个样式，使其不可滚动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;div :class=\u0026#34;isPopup ? \u0026#39;disableRoll\u0026#39; : \u0026#39;\u0026#39;\u0026#34;\u0026gt; \u0026lt;div\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { isPopup: false, } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .disableRoll { overflow: hidden; position: fixed; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; ","date":"2021-11-25T16:13:10Z","permalink":"https://blog.hunterji.com/p/vue%E7%A6%81%E6%AD%A2%E9%81%AE%E7%BD%A9%E5%B1%82%E4%B8%8B%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/","title":"vue禁止遮罩层下的页面滚动"},{"content":"前言 最近空下来，正好找个项目尝鲜，把vue3+ts+setup哐哐全堆上，试试最新的前端技术。\n从最先体会到的变化，就是关于响应式APIs了。遇到不好问题，怪我没有理解文档/狗头。比如说：\n明明这个数据改了，怎么没渲染出来？ 同样是Arrary，怎么套了个reactive就类型不一样了？ 所以这里基于遇到的几个问题，来写个笔记。\n简单对比 响应式官方文档 官方案例如下：\n1 2 3 4 5 6 7 8 9 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;{{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 我们可以先看看，如果是vue2，怎么做呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt; export default { data() { return { count: 0 } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;{{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 可以很明显地看到此处的count跟上面的官方文档不同，使用了ref方法。这就是setup中的响应式APIs，需要预先声明响应式变量。\n如果，不声明呢？那就是直接写成如下：\n1 const count = 0 运行一下，首先你会发现，没有任何报错，代码正常运行。但是当你在浏览器上查看，开始改变count的值时，就会发现，怎么页面没有变化？\n所以，需要手动命名响应，才会在值变化时触发视图渲染。\nref 现在来详细讲讲ref，该方法常用于单个变量，比如：\n1 2 ref(0) ref(\u0026#34;hello\u0026#34;) 这里需要说明一个问题，那就是ref(\u0026quot;hello\u0026quot;) !== \u0026quot;hello\u0026quot;。这就是我说的，为什么同样的值，类型就不同了。那是因为ref返回的是一个Proxy，而非原来的值。在视图中可直接使用，但是在js/ts中操作，需要使用.value来操作，如下所示：\n1 2 3 4 5 let name = ref(\u0026#34;kuari\u0026#34;) function changeName() { name.value = \u0026#34;tom\u0026#34; } reactive reactive不同于ref的点在于，其是“深层”的——它影响所有嵌套 property。也就是说，其可用在对象或者数组上。\n1 2 3 4 let form = reactive({ name: \u0026#34;kuari\u0026#34;, desc: \u0026#34;developer\u0026#34; }) 其返回类型也是Proxy，不同点在于，可以直接修改某一个元素的，如下所示：\n1 form.name = \u0026#34;tom\u0026#34; 但是如果你想整个替换就会报错了。\n1 form = {...} // 报错，类型不同 当使用的是数组时，如果想整个替换，可以将其写成对象，代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let selected = reactive({ arr: [ { label: \u0026#34;vue\u0026#34;, value: 0 }, { label: \u0026#34;typescript\u0026#34;, value: 1 } ] }) // 使用 console.log(selected.arr) // 整个替换 selected.arr = [...] 关于reactive跟ref一起使用，reactive 将解包所有深层的ref，同时维持 ref 的响应性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const count = ref(1) const obj = reactive({ count }) // ref 会被解包 console.log(obj.count === count.value) // true // 它会更新 `obj.count` count.value++ console.log(count.value) // 2 console.log(obj.count) // 2 // 它也会更新 `count` ref obj.count++ console.log(obj.count) // 3 console.log(count.value) // 3 总结 setup总体来说，用起来真的会更加简洁，而响应式虽然好像比之前麻烦些了，但是一定层面上让开发对对于程序有了更深入的操控。墙裂推荐一波！后面再来详细讲讲对于新特性的体验。\n","date":"2021-11-04T20:48:09Z","permalink":"https://blog.hunterji.com/p/vue3-script-setup%E5%93%8D%E5%BA%94%E5%BC%8F%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"vue3 script setup响应式初体验"},{"content":"前言 前端小伙伴儿们是不是经常遇到ui组件全局引入导致体积太大，按需引入导致不断手写会很麻烦。所以，当当！今天我们来让代码自己按需引入，解放前端小伙伴儿们的生产力，早日实现下班自由！（甲方：我要再改十个需求！）\n介绍 我们这里介绍的是unplugin-vue-components。该组件是由vue核心开发成员antfu开发的，尤大也是推荐的，且是该项目的金牌赞助商。\n该组件主要是为了实现vue项目的组件自动引入。\n官方文档：antfu/unplugin-vue-components\n完整案例 此处我们以vite为例，来主要看一下其对于自定义组件和UI库组件的自动按需引入。\n源码：https://github.com/Kuari/Blog/tree/master/Examples/unplugin_auto_import\n创建项目 1 yarn create vite unplugin_auto_import --template vue 然后进入文件夹安装依赖。\n1 2 cd unplugin_auto_import yarn install 安装unplugin-vue-components 1 yarn add -D unplugin-vue-components 配置vite.config.js 1 2 3 4 5 6 7 8 9 10 11 import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import Components from \u0026#39;unplugin-vue-components/vite\u0026#39; // 新增 // https://vitejs.dev/config/ export default defineConfig({ plugins: [ vue(), Components({ /* options */ }) // 新增 ] }) 自动引入自定义组件 我们默认模板创建的项目中，默认在App.vue中引入了./components/HelloWorld.vue。此处就可以来尝试下如何自动引入了。\n在配置了unplugin-vue-components之后，现在只需要删除引入行（其实这时候打开vscode就会发现改行已经灰掉了），被删除行如下所示：\n1 import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39; 删除以后完整App.vue如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34; /\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Hello Vue 3 + Vite\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; 现在在命令行中运行yarn dev，再打开浏览器查看http://localhost:3000页面，是不是发现，哎？！居然引入了！（心中狂喜，要早日实现下班自由了）\n自动引入UI库组件 这里以element plus为例。\n首先是安装element plus。官方文档也没说要装，我还以为内置呢，一直报错，有点懵逼，哈哈。\n1 yarn add -D element-plus 引入element plus的resolver，此处编辑vite.config.js文件，修改后如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import Components from \u0026#39;unplugin-vue-components/vite\u0026#39; import { ElementPlusResolver } from \u0026#39;unplugin-vue-components/resolvers\u0026#39; // 引入ElementPlusResolver // https://vitejs.dev/config/ export default defineConfig({ plugins: [ vue(), Components({resolvers: [ElementPlusResolver()]}) // 添加配置 ] }) 那么现在神奇的事情来了，就可以直接使用UI库的组件了！\n我们在App.vue中使用一个el-button组件试试。我们在App.vue中加入如下行：\n1 \u0026lt;el-button type=\u0026#34;primary\u0026#34;\u0026gt;Kuari\u0026lt;/el-button\u0026gt; 添加后App.vue上下代码如下：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34; /\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Hello Vue 3 + Vite\u0026#34; /\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34;\u0026gt;Kuari\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; 现在，运行yarn dev，打开浏览器，可以看到，就直接可以使用UI库的组件了。\n打包 按需引入的功能并不是仅仅在开发时候的，在打包时，该组件也是Tree-shakable的，只会将你用了的组件打包。\n按照当前教程所写的项目，当全局引入的时候，打包的dist文件夹为1.1MB，而使用该组件之后打包，其dist文件夹为202KB。\n最后 手动按需导入是不可能手动按需导入的，这辈子都不可能了/狗头。\n毕竟是大佬开发的强力工具，希望前端小伙伴儿们早日实现下班自由。\n","date":"2021-10-27T15:28:00Z","permalink":"https://blog.hunterji.com/p/%E4%BD%A0%E6%98%AF%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%81%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E4%BA%86/","title":"你是个成熟的代码要学会自己按需引入了"},{"content":"简介 在上一篇文章Vite+Electron快速构建一个VUE3桌面应用中，我们了解了如何使用Vite和Electron来快速构建一个Vue3桌面应用。但是，之前构建的应用仅仅是一个简单的版本。在开发过程中，为了更好的开发体验，在开发electron的时候，肯定也希望能有动态模块热重载（HMR），更别说vite那迅雷不及掩耳盗铃儿响叮当之势的加载速度。\n因此，接着上一篇文章所完成的项目代码，我们来完成Vite和Electron开发时的动态模块热重载功能。\n源码：https://github.com/Kuari/Blog/tree/master/Examples/vite_electron/vite_electron_2\n系列文章：\nVite+Electron快速构建一个VUE3桌面应用 Vite+Electron快速构建一个VUE3桌面应用(二)——动态模块热重载 Vite+Electron快速构建一个VUE3桌面应用(三)——打包 思路 先说结论，可利用electron中的mainWindow.loadURL(\u0026lt;your-url\u0026gt;)来实现。\n对于动态模块热重载功能来说，无论是webpack还是vite，其都是将构建内容存入内存，因此我们无法使用mainWindow.loadFile('dist/index.html')这样加载文件的方式。\n但是，单纯地改变该配置也是不行的，需要使用vite将开发服务器运行起来，可以正常运行动态模块热重载，而electron直接加载其开发服务器可访问的url，即http://localhost:3000。\n实现步骤 编辑main.js 将mainWindow.loadFile('dist/index.html')更新为mainWindow.loadURL(\u0026quot;http://localhost:3000\u0026quot;)，更新后的文件如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // main.js // 控制应用生命周期和创建原生浏览器窗口的模组 const { app, BrowserWindow } = require(\u0026#39;electron\u0026#39;) const path = require(\u0026#39;path\u0026#39;) function createWindow () { // 创建浏览器窗口 const mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, \u0026#39;preload.js\u0026#39;) } }) // 加载 index.html // mainWindow.loadFile(\u0026#39;dist/index.html\u0026#39;) 将该行改为下面这一行，加载url mainWindow.loadURL(\u0026#34;http://localhost:3000\u0026#34;) // 打开开发工具 // mainWindow.webContents.openDevTools() } // 这段程序将会在 Electron 结束初始化 // 和创建浏览器窗口的时候调用 // 部分 API 在 ready 事件触发后才能使用。 app.whenReady().then(() =\u0026gt; { createWindow() app.on(\u0026#39;activate\u0026#39;, function () { // 通常在 macOS 上，当点击 dock 中的应用程序图标时，如果没有其他 // 打开的窗口，那么程序会重新创建一个窗口。 if (BrowserWindow.getAllWindows().length === 0) createWindow() }) }) // 除了 macOS 外，当所有窗口都被关闭的时候退出程序。 因此，通常对程序和它们在 // 任务栏上的图标来说，应当保持活跃状态，直到用户使用 Cmd + Q 退出。 app.on(\u0026#39;window-all-closed\u0026#39;, function () { if (process.platform !== \u0026#39;darwin\u0026#39;) app.quit() }) // 在这个文件中，你可以包含应用程序剩余的所有部分的代码， // 也可以拆分成几个文件，然后用 require 导入。 编辑vite.config.js 修改文件vite.config.js的base，修改后的文件如下所示：\n1 2 3 4 5 6 7 8 9 10 // vite.config.js import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ base: \u0026#34;./\u0026#34;,\t// 新增 plugins: [vue()] }) 同时开启vite和electron服务 为了使vite和electron正常运行，需要先运行vite，使得其开发服务器的url可以正常访问，然后再开启electron去加载url。\n此处需要安装两个库：\nconcurrently：阻塞运行多个命令，-k参数用来清除其它已经存在或者挂掉的进程 wait-on：等待资源，此处用来等待url可访问 首先来安装。\n1 yarn add -D concurrently wait-on 接着更新文件package.json，scripts新增两条命令：\n1 2 3 4 \u0026#34;scripts\u0026#34;: { \u0026#34;electron\u0026#34;: \u0026#34;wait-on tcp:3000 \u0026amp;\u0026amp; electron .\u0026#34;, \u0026#34;electron:serve\u0026#34;: \u0026#34;concurrently -k \\\u0026#34;yarn dev\\\u0026#34; \\\u0026#34;yarn electron\\\u0026#34;\u0026#34; }, 更新后完整内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;name\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;electron\u0026#34;: \u0026#34;wait-on tcp:3000 \u0026amp;\u0026amp; electron .\u0026#34;, \u0026#34;electron:serve\u0026#34;: \u0026#34;concurrently -k \\\u0026#34;yarn dev\\\u0026#34; \\\u0026#34;yarn electron\\\u0026#34;\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;vue\u0026#34;: \u0026#34;^3.2.16\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@vitejs/plugin-vue\u0026#34;: \u0026#34;^1.9.3\u0026#34;, \u0026#34;concurrently\u0026#34;: \u0026#34;^6.3.0\u0026#34;, \u0026#34;cross-env\u0026#34;: \u0026#34;^7.0.3\u0026#34;, \u0026#34;electron\u0026#34;: \u0026#34;^15.1.2\u0026#34;, \u0026#34;vite\u0026#34;: \u0026#34;^2.6.4\u0026#34;, \u0026#34;wait-on\u0026#34;: \u0026#34;^6.0.0\u0026#34; } } 运行 现已添加两条命令：\nyarn electron为等待tcp协议3000端口可访问，然后执行electron yarn electron:serve为阻塞执行开发服务器运行和yarn electron命令 运行项目只要执行命令yarn electron:serve即可，当修改项目文件时，桌面应用也将自动更新。\n参考文件 为什么选vite vite+vue3+electron+typescript ","date":"2021-10-25T16:07:10Z","permalink":"https://blog.hunterji.com/p/vite-electron%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAvue3%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E4%BA%8C%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97%E7%83%AD%E9%87%8D%E8%BD%BD/","title":"Vite+Electron快速构建一个VUE3桌面应用(二)——动态模块热重载"},{"content":"简介 关于测试工程师，有一个笑话，是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 一个测试工程师走进一家酒吧，要了一杯啤酒 一个测试工程师走进一家酒吧，要了一杯咖啡 一个测试工程师走进一家酒吧，要了0.7杯啤酒 一个测试工程师走进一家酒吧，要了-1杯啤酒 一个测试工程师走进一家酒吧，要了2^32杯啤酒 一个测试工程师走进一家酒吧，要了一杯洗脚水 一个测试工程师走进一家酒吧，要了一杯蜥蜴 一个测试工程师走进一家酒吧，要了一份asdfQwer@24dg!\u0026amp;*(@ 一个测试工程师走进一家酒吧，什么也没要 一个测试工程师走进家酒吧，又走出去又从窗户进来又从后门出去从下水道钻进来 一个测试工程师走进家酒吧，又走出去又进来又出去又进来又出去，最后在外面把老板打了一顿 一个测试工程师走进一 一个测试工程师走进一家酒吧，要了一杯烫烫烫的锟斤拷 一个测试工程师走进一家酒吧，要了NaN杯Null 1T测试工程师冲进一家酒吧，要了500T啤酒咖啡洗脚水野猫狼牙棒奶茶 1T测试工程师把酒吧拆了 一个测试工程师化装成老板走进一家酒吧，要了500杯啤酒，并且不付钱 一万个测试工程师在酒吧外呼啸而过 一个测试工程师走进一家酒吧，要了一杯啤酒‘;DROPTABLE酒吧 测试工程师们满意地离开了酒吧 这个笑话估计也只有开发才明白其中的笑点与心酸吧。\n对于一些刚入门的开发来说，这简直就是噩梦。当初刚入门的时候我的代码也是很多毛病，经不起这样的测试，后来渐渐地经验多了后，代码的健壮性逐渐提升，也明白其中比较重要的就是参数的校验。\n参数的使用有通过协议的接口调用（如http、rpc\u0026hellip;\u0026hellip;）、函数调用、库调用等等方式。\n其实对于http api的请求来说，现在很多web框架都已经自带了参数校验的功能，基本用起来都挺爽的，也无需多讲。\n而对于函数调用这样的常见方式，很多是要靠开发自己去校验参数的。如果仅仅是靠注释，在团队开发过程中，难免会有问题产生。起码我觉得，永远不要相信传过来的参数！\nOK，那么来讲讲这次的题目，就是Golang中的参数校验库——validator。\n用过Gin的小伙伴儿应该知道其binding参数验证器非常好用，其就是调用了validator。此处呢我们来介绍下validator的基础用法，和在一般场景下的应用案例。\n基础用法 介绍 validator包源码在github.com/go-playground/validator。其基于标记实现结构和单个字段的值验证，包含如下关键功能：\n使用验证标记或自定义验证程序进行跨字段和跨结构验证 Slice、Array和Map都可以允许验证多维字段的任何或者所有级别 能够深入查看映射键和值以进行验证 通过在验证之前确定类型接口的基础类型来处理类型接口 处理自定义字段类型 允许将多个验证映射到单个标记，以便在结构上更轻松地定义验证 提取自定义定义的字段名，例如，可以指定在验证时提取JSON名称，并使其在结果FieldError中可用 可定制的i18n错误消息 gin web框架的默认验证器 安装 1 go get github.com/go-playground/validator/v10 导入 1 import \u0026#34;github.com/go-playground/validator/v10\u0026#34; 验证规则 此处从官方列举的各个类别中挑选部分举例说明。\n1）比较 eq：相等 gt：大于 gte：大于等于 lt：小于 lte：小于等于 ne：不等于 2）字段 此处的字段大部分可以理解为上面的比较的tag跟field拼接而成，而中间有cs的tag为跨struct比较。\neqfield(=Field)：必须等于Field的值 nefield(=Field)：必须不等于Field的值 gtfield(=Field)：必须大于Field的值 eqcsfield(=Other.Field)：必须等于struct Other中的Field的值 3）网络 ip：网络协议地址IP ip4_addr：网络协议地址IPv4 mac：mac地址 url：url 4）字符 ascii：ASCII boolean：Boolean endswith： 以\u0026hellip;结尾 contains：包含 uppercase：大写 5）格式 base64：Base64字符串 base64url：Base64url字符串 email：邮箱字符串 json：JSON jwt：JSON Web Token latitude：纬度 6）其它 len：长度 max：最大值 min：最小值 required：字段为必须，不可空 7）别名 iscolor：hexcolor|rgb|rgba|hsl|hsla country_code：iso3166_1_alpha2|iso3166_1_alpha3|iso3166_1_alpha_numeric 案例 简单验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/go-playground/validator/v10\u0026#34; ) type User struct { Name string `validate:\u0026#34;required,lte=10\u0026#34;` // 姓名 非空，长度小于等于10 Age int `validate:\u0026#34;required,gte=18,lte=50\u0026#34;` // 年龄 非空，数字大于等于18，小于等于50 Email string `validate:\u0026#34;required,email\u0026#34;` // 邮箱 非空，格式为email FavouriteColor string `validate:\u0026#34;iscolor\u0026#34;` // 喜欢的颜色 hexcolor|rgb|rgba|hsl|hsla的别名 Password string `validate:\u0026#34;required,gte=16,lte=22\u0026#34;` // 密码 非空，长度大于等于16，小于等于22 RePassword string `validate:\u0026#34;required,gte=16,lte=22,eqfield=Password\u0026#34;` // 确认密码 非空，长度大于等于16，小于等于22，必须和字段Password相同 Hobbies []Hobby `validate:\u0026#34;lte=5\u0026#34;` // 多个爱好 长度小于等于5 } type Hobby struct { Name string `validate:\u0026#34;lte=50\u0026#34;` // 爱好名称 长度小于等于50 } var validate *validator.Validate func main() { validate = validator.New() // 该函数验证struct // 不会报错 validateStruct() // 该函数单度验证字段 // 会报错 validateVariable() } func validateStruct() { hobby := Hobby{ Name: \u0026#34;划水\u0026#34;, } user := User{ Name: \u0026#34;张三\u0026#34;, Age: 48, Email: \u0026#34;hi.hunterji@gmail.com\u0026#34;, FavouriteColor: \u0026#34;#ffffff\u0026#34;, Password: \u0026#34;1234567890123456\u0026#34;, RePassword: \u0026#34;1234567890123456\u0026#34;, Hobbies: []Hobby{hobby}, } err := validate.Struct(user) if err != nil { fmt.Println(err) } } func validateVariable() { email := \u0026#34;hi.hunterji@gmail.com\u0026#34; // 此处邮箱地址格式写的是错误的，会导致报错 err := validate.Var(email, \u0026#34;required,email\u0026#34;) if err != nil { fmt.Println(err) } } 自定义验证 自定义验证可以自己创建一个校验的函数：\n1 2 3 4 // 注册校验函数 func ValidateMyVal(fl validator.FieldLevel) bool { return fl.Field().String() == \u0026#34;hello,world!\u0026#34; } 然后将其注册到validate上即可：\n1 2 3 4 5 6 7 8 validate = validator.New() validate.RegisterValidation(\u0026#34;is-hello\u0026#34;, ValidateMyVal) s := \u0026#34;hello,kuari\u0026#34; // 跟校验函数中的字符串不同，因此此处会报错 err := validate.Var(s, \u0026#34;is-hello\u0026#34;) if err != nil { fmt.Println(err) } 自定义校验可以满足开发过程中的特殊场景，通过制定规范的校验标准，可以推进团队的协作和开发效率。\n最后 至此便是对于validator的介绍了。本文篇幅较短，管中窥豹而已，基本可以满足简单场景的使用。以及本文的案例也是基于官方的案例改的，让其稍微接地气点。若有兴趣的小伙伴还是建议去完整看一下官方的文档和案例，多样的用法可以满足多样的场景，在满足代码的健壮性的同时也能确保代码的优美。\n参考文档 go-playground/validator ","date":"2021-10-23T15:31:19Z","permalink":"https://blog.hunterji.com/p/golang%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8validator%E6%A0%A1%E9%AA%8C%E5%8F%82%E6%95%B0/","title":"Golang如何使用validator校验参数"},{"content":"简介 上一篇文章Vite+Electron快速构建一个VUE3桌面应用(二)——动态模块热重载完成了开发时的动态模块热重载功能，现在是时候来看看怎么完成最后一步——打包了。\n源码：https://github.com/Kuari/Blog/tree/master/Examples/vite_electron/vite_electron_3\n系列文章：\nVite+Electron快速构建一个VUE3桌面应用 Vite+Electron快速构建一个VUE3桌面应用(二)——动态模块热重载 Vite+Electron快速构建一个VUE3桌面应用(三)——打包 思路 先说结论，重点还是在于mainWindow.loadURL()。\n打包后还是加载http://localhost:3000是无法运行的，因此，此处需要先用vite打包好，然后使用electron-builder加载vite打包后的文件进行打包。\n为了代码能够根据不同环境在运行时加载http://localhost:3000，在打包时加载文件，此处需要使用环境变量来切换生产和开发环境。\n实现 环境变量 此处使用环境变量NODE_ENV来切换生产和开发环境，生产环境为NODE_ENV=production，开发环境为NODE_ENV=development，若有其它如release等环境可在此基础上拓展。\n创建electron文件夹 在项目根目录下创建文件夹electron，将main.js和preload.js文件移动进来。其结构如下所示：\n1 2 3 4 5 6 . ├── README.md ├── electron │ ├── main.js │ └── preload.js ... 若还是不太明白可以看看源码中文件结构。\n编辑electron/main.js 该文件主要是需要根据环境变量切换electron加载的内容，修改内容如下：\n1 2 3 4 5 mainWindow.loadURL( NODE_ENV === \u0026#39;development\u0026#39; ? \u0026#39;http://localhost:3000\u0026#39; :`file://${path.join(__dirname, \u0026#39;../dist/index.html\u0026#39;)}` ); 修改后的完整内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // electron/main.js // 控制应用生命周期和创建原生浏览器窗口的模组 const { app, BrowserWindow } = require(\u0026#39;electron\u0026#39;) const path = require(\u0026#39;path\u0026#39;) const NODE_ENV = process.env.NODE_ENV function createWindow () { // 创建浏览器窗口 const mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, \u0026#39;preload.js\u0026#39;) } }) // 加载 index.html // mainWindow.loadFile(\u0026#39;dist/index.html\u0026#39;) 将该行改为下面这一行，加载url mainWindow.loadURL( NODE_ENV === \u0026#39;development\u0026#39; ? \u0026#39;http://localhost:3000\u0026#39; :`file://${path.join(__dirname, \u0026#39;../dist/index.html\u0026#39;)}` ); // 打开开发工具 if (NODE_ENV === \u0026#34;development\u0026#34;) { mainWindow.webContents.openDevTools() } } // 这段程序将会在 Electron 结束初始化 // 和创建浏览器窗口的时候调用 // 部分 API 在 ready 事件触发后才能使用。 app.whenReady().then(() =\u0026gt; { createWindow() app.on(\u0026#39;activate\u0026#39;, function () { // 通常在 macOS 上，当点击 dock 中的应用程序图标时，如果没有其他 // 打开的窗口，那么程序会重新创建一个窗口。 if (BrowserWindow.getAllWindows().length === 0) createWindow() }) }) // 除了 macOS 外，当所有窗口都被关闭的时候退出程序。 因此，通常对程序和它们在 // 任务栏上的图标来说，应当保持活跃状态，直到用户使用 Cmd + Q 退出。 app.on(\u0026#39;window-all-closed\u0026#39;, function () { if (process.platform !== \u0026#39;darwin\u0026#39;) app.quit() }) // 在这个文件中，你可以包含应用程序剩余的所有部分的代码， // 也可以拆分成几个文件，然后用 require 导入。 编辑package.json 首先修改main 属性，将main: main.js改为main: electron/main.js。\n1 2 3 4 5 6 { \u0026#34;name\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;electron/main.js\u0026#34;, ... } 接着，编辑build属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026#34;build\u0026#34;: { \u0026#34;appId\u0026#34;: \u0026#34;com.your-website.your-app\u0026#34;, \u0026#34;productName\u0026#34;: \u0026#34;ElectronApp\u0026#34;, \u0026#34;copyright\u0026#34;: \u0026#34;Copyright © 2021 \u0026lt;your-name\u0026gt;\u0026#34;, \u0026#34;mac\u0026#34;: { \u0026#34;category\u0026#34;: \u0026#34;public.app-category.utilities\u0026#34; }, \u0026#34;nsis\u0026#34;: { \u0026#34;oneClick\u0026#34;: false, \u0026#34;allowToChangeInstallationDirectory\u0026#34;: true }, \u0026#34;files\u0026#34;: [ \u0026#34;dist/**/*\u0026#34;, \u0026#34;electron/**/*\u0026#34; ], \u0026#34;directories\u0026#34;: { \u0026#34;buildResources\u0026#34;: \u0026#34;assets\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;dist_electron\u0026#34; } } 然后，更新scripts属性。\n此处需要先安装两个库：\ncross-env: 该库让开发者只需要注重环境变量的设置，而无需担心平台设置 electron-builder: electron打包库 1 yarn add -D cross-env electron-builder 更新后的scripts如下：\n1 2 3 4 5 6 7 8 { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;electron\u0026#34;: \u0026#34;wait-on tcp:3000 \u0026amp;\u0026amp; cross-env NODE_ENV=development electron .\u0026#34;, // 此处需要设置环境变量以保证开发时加载url \u0026#34;electron:serve\u0026#34;: \u0026#34;concurrently -k \\\u0026#34;yarn dev\\\u0026#34; \\\u0026#34;yarn electron\\\u0026#34;\u0026#34;, \u0026#34;electron:build\u0026#34;: \u0026#34;vite build \u0026amp;\u0026amp; electron-builder\u0026#34; // 新增打包命令 } 最后，更新后的package.json完整内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 { \u0026#34;name\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;electron/main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;electron\u0026#34;: \u0026#34;wait-on tcp:3000 \u0026amp;\u0026amp; cross-env NODE_ENV=development electron .\u0026#34;, \u0026#34;electron:serve\u0026#34;: \u0026#34;concurrently -k \\\u0026#34;yarn dev\\\u0026#34; \\\u0026#34;yarn electron\\\u0026#34;\u0026#34;, \u0026#34;electron:build\u0026#34;: \u0026#34;vite build \u0026amp;\u0026amp; electron-builder\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;vue\u0026#34;: \u0026#34;^3.2.16\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@vitejs/plugin-vue\u0026#34;: \u0026#34;^1.9.3\u0026#34;, \u0026#34;concurrently\u0026#34;: \u0026#34;^6.3.0\u0026#34;, \u0026#34;cross-env\u0026#34;: \u0026#34;^7.0.3\u0026#34;, \u0026#34;electron\u0026#34;: \u0026#34;^15.1.2\u0026#34;, \u0026#34;electron-builder\u0026#34;: \u0026#34;^22.13.1\u0026#34;, \u0026#34;vite\u0026#34;: \u0026#34;^2.6.4\u0026#34;, \u0026#34;wait-on\u0026#34;: \u0026#34;^6.0.0\u0026#34; }, \u0026#34;build\u0026#34;: { \u0026#34;appId\u0026#34;: \u0026#34;com.my-website.my-app\u0026#34;, \u0026#34;productName\u0026#34;: \u0026#34;MyApp\u0026#34;, \u0026#34;copyright\u0026#34;: \u0026#34;Copyright © 2021 kuari\u0026#34;, \u0026#34;mac\u0026#34;: { \u0026#34;category\u0026#34;: \u0026#34;public.app-category.utilities\u0026#34; }, \u0026#34;nsis\u0026#34;: { \u0026#34;oneClick\u0026#34;: false, \u0026#34;allowToChangeInstallationDirectory\u0026#34;: true }, \u0026#34;files\u0026#34;: [ \u0026#34;dist/**/*\u0026#34;, \u0026#34;electron/**/*\u0026#34; ], \u0026#34;directories\u0026#34;: { \u0026#34;buildResources\u0026#34;: \u0026#34;assets\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;dist_electron\u0026#34; } } } 打包 直接执行打包命令即可开始打包。\n1 yarn electron:build 打包完成之后，会多出两个文件夹dist和dist_electron，其文件结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . ├── README.md ├── dist │ ├── assets │ ├── favicon.ico │ └── index.html ├── dist_electron │ ├── MyApp-0.0.0-mac.zip │ ├── MyApp-0.0.0-mac.zip.blockmap │ ├── MyApp-0.0.0.dmg │ ├── MyApp-0.0.0.dmg.blockmap │ ├── builder-debug.yml │ ├── builder-effective-config.yaml │ └── mac ... 至此，便完成了打包。\n后面再来写写关于electron的优化，减少electron打包后应用的体积。（这玩意儿确实打包下来有点大呢/狗头）\n","date":"2021-10-19T15:26:46Z","permalink":"https://blog.hunterji.com/p/vite-electron%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAvue3%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E4%B8%89%E6%89%93%E5%8C%85/","title":"Vite+Electron快速构建一个VUE3桌面应用(三)——打包"},{"content":"简介 首先，介绍下vite和Electron。\nVite是一种新型前端构建工具，能够显著提升前端开发体验。由尤大推出，其发动态表示“再也回不去webpack了\u0026hellip;” Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入Chromium和Node.js到二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。 当开始想用vue去开发一个桌面应用时，首先去搜索下，了解到当前如下两种现成方案：\nelectron-vue： 该项目集成度较好，封装较为完整，中文搜索下来文章较多也是该方案，可以直接上手去使用。但是，问题在于其内置electron的版本太低，写文章时看到的版本是2.0.4，而最新的electron版本是15.1.2。 Vue CLI Plugin Electron Builder： 该方案是集成到到vue-cli中使用，使用vue add electron-builder后可直接上手，免去了基础配置的步骤。但是其只能在vue-cli下使用，无法配合vite来使用。 因此，若要使用vite和electron，还需要自己来配置。\n源码：https://github.com/Kuari/Blog/tree/master/Examples/vite_electron/vite_electron_1\n创建一个Vite项目 安装 vite 1 yarn create vite 创建项目 创建命令如下：\n1 yarn create vite \u0026lt;your-vue-app-name\u0026gt; --template vue 此处创建一个项目，名为kuari。\n1 yarn create vite kuari --template vue 进入且运行 进入项目，在运行前需要先安装下依赖。\n1 2 3 cd kuari yarn install yarn dev 在运行命令敲下的一瞬间，几乎是已经在运行了，不愧是vite。此时按照输出，打开地址预览，即可看到初始化页面。\n至此一个基础的vite项目创建完成。\n配置Electron 官方文档 在Electron官网的快速入门文档中，有官方给出的利用html、javascript、css来创建一个electron应用的案例，vite+electron的方案也借鉴其中。\n安装 首先安装electron至vite应用。目前electron的版本为^15.1.2,。\n1 yarn add --dev electron 配置文件 ####config.js\n1 2 3 4 5 6 7 8 9 import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import path from \u0026#39;path\u0026#39; // 新增 // https://vitejs.dev/config/ export default defineConfig({ base: path.resolve(__dirname, \u0026#39;./dist/\u0026#39;),\t// 新增 plugins: [vue()] }) ####js\n创建一个新的文件main.js，需要注意的是，该内容中index.html的加载路径跟electron官网给的配置不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // main.js // 控制应用生命周期和创建原生浏览器窗口的模组 const { app, BrowserWindow } = require(\u0026#39;electron\u0026#39;) const path = require(\u0026#39;path\u0026#39;) function createWindow () { // 创建浏览器窗口 const mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, \u0026#39;preload.js\u0026#39;) } }) // 加载 index.html mainWindow.loadFile(\u0026#39;dist/index.html\u0026#39;) // 此处跟electron官网路径不同，需要注意 // 打开开发工具 // mainWindow.webContents.openDevTools() } // 这段程序将会在 Electron 结束初始化 // 和创建浏览器窗口的时候调用 // 部分 API 在 ready 事件触发后才能使用。 app.whenReady().then(() =\u0026gt; { createWindow() app.on(\u0026#39;activate\u0026#39;, function () { // 通常在 macOS 上，当点击 dock 中的应用程序图标时，如果没有其他 // 打开的窗口，那么程序会重新创建一个窗口。 if (BrowserWindow.getAllWindows().length === 0) createWindow() }) }) // 除了 macOS 外，当所有窗口都被关闭的时候退出程序。 因此，通常对程序和它们在 // 任务栏上的图标来说，应当保持活跃状态，直到用户使用 Cmd + Q 退出。 app.on(\u0026#39;window-all-closed\u0026#39;, function () { if (process.platform !== \u0026#39;darwin\u0026#39;) app.quit() }) // 在这个文件中，你可以包含应用程序剩余的所有部分的代码， // 也可以拆分成几个文件，然后用 require 导入。 ####js\n创建一个新的文件preload.js。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // preload.js // 所有Node.js API都可以在预加载过程中使用。 // 它拥有与Chrome扩展一样的沙盒。 window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { const replaceText = (selector, text) =\u0026gt; { const element = document.getElementById(selector) if (element) element.innerText = text } for (const dependency of [\u0026#39;chrome\u0026#39;, \u0026#39;node\u0026#39;, \u0026#39;electron\u0026#39;]) { replaceText(`${dependency}-version`, process.versions[dependency]) } }) ####json\n为了确保能够运行相关electron的命令，需要修改package.json文件。\n首先需要去设置main属性，electron默认会去在开始时寻找项目根目录下的index.js文件，此处我们使用的是main.js，所以需要去定义下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // package.json { \u0026#34;name\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, // 新增 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;vite preview\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;vue\u0026#34;: \u0026#34;^3.2.16\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@vitejs/plugin-vue\u0026#34;: \u0026#34;^1.9.3\u0026#34;, \u0026#34;electron\u0026#34;: \u0026#34;^15.1.2\u0026#34;, \u0026#34;vite\u0026#34;: \u0026#34;^2.6.4\u0026#34; } } 最后我们需要新增electron的运行命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // package.json { \u0026#34;name\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;electron:serve\u0026#34;: \u0026#34;electron .\u0026#34; // 新增 }, \u0026#34;dependencies\u0026#34;: { \u0026#34;vue\u0026#34;: \u0026#34;^3.2.16\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@vitejs/plugin-vue\u0026#34;: \u0026#34;^1.9.3\u0026#34;, \u0026#34;electron\u0026#34;: \u0026#34;^15.1.2\u0026#34;, \u0026#34;vite\u0026#34;: \u0026#34;^2.6.4\u0026#34; } } 运行 直接在终端输入如下命令：\n1 yarn electron:serve 接着我们就可以看到我们桌面应用就出来咯！\n最后 之前做项目一直用的Vue CLI Plugin Electron Builder，这次有个项目先用electron开发一下，推一波看看，后期看情况swift重新开发一个mac的桌面应用。也刚好尝尝鲜，一直没有机会试试vite。\nelectron这个东东确实很方便，就是打包出来的应用体积太大，真的是硬伤啊。这次目标人群首先是windows用户，所以上electron吧！\n参考文档 Electron官网快速入门 Vite官网 Build vue3 desktop apps in just 5 minutes ","date":"2021-10-18T09:58:57Z","permalink":"https://blog.hunterji.com/p/vite-electron%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAvue3%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/","title":"Vite+Electron快速构建一个VUE3桌面应用"},{"content":"简介 在上一篇文章——前端文件花式直传OSS！后端：那我走？中聊了下文件上传的几种方案，这里我们再来聊一下文件下载的花式姿势。\n精简版 最常见的方式，莫过于后端存储文件在服务器上，然后通过后端接口传给前端，如下图所示。\n该方案对于小规模、成本较低的项目非常适用，开发也较为便捷。\n而对于有性能要求的项目，可以通过砸钱加机器、分片下载等方案提升项目性能。如果可以的话，请砸钱加机器吧！\n中庸版 相较于上一个方案，可以砸丢丢钱整个OSS，将文件存储在OSS上，毕竟OSS上行流量不收费，如下图所示。\n那么问题来了，OSS的下行流量不是收费的吗？！\nOK，偷偷告诉各位一个省钱小妙招/狗头，OSS内网的下行流量是不收费的！因此，可以通过后端请求OSS，获取到文件/字符串后，将其以文件流/base64数据的方式返回给前端。这样就避免了下行流量的费用。如下图所示。\n不过问题又来了，这样就还是占用了后端服务器的资源，依然会是性能的一个瓶颈。\n性能版 基于上一个方案，可以再升级。砸丢丢钱，拉上CDN这老哥，利用CDN流量代替OSS的下行流量，既能让前端直接请求OSS资源，不占用服务器资源，也降低了成本。如图所示。\n在优先性能的情况下，该方案是较优的。\n要说缺点的话，就是CDN配置吧，需要买域名和SSL证书等，不过一次购买，后续使用体验会非常棒。CDN除了可以代替OSS的下行流量外，其优点不要太多，比如说CDN可以文件缓存、可以调度至加速节点等。\n涉及到OSS的私有Bucket的话，只需要使用CDN的访问控制即可。其也只需要通过后端实现加密，生成文件访问URL给前端直接访问。\n或许你会存在疑问，看上去挺麻烦的啊！但是看看CDN的价格，你肯定会有不一样的想法的。\n","date":"2021-09-29T09:22:22Z","permalink":"https://blog.hunterji.com/p/oss%E8%8A%B1%E5%BC%8F%E8%A7%A3%E9%94%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%96%B0%E5%A7%BF%E5%8A%BF%E4%BD%A0%E5%AD%A6%E5%BA%9F%E4%BA%86%E5%90%97/","title":"OSS花式解锁下载文件新姿势，你学废了吗？"},{"content":"简介 前端还在传文件给后端吗？你们的服务器扛得住吗？什么\u0026hellip;\u0026hellip;老板砸钱加机器？！告辞！/狗头\n前后端文件传输涉及数据较大，往往会成为很多项目的性能瓶颈。常见的传输方式也有不少，相对来说，OSS直传能够减轻很大压力。\n本文我们来列举下常见的和oss直传的几种传输方式，并列举其优劣。\n常见方式 表单上传 表单上传文件是最常见的方式，前后端开发小伙伴都很轻松，前端哐哐传，后端哐哐收就成了。其过程如下图所示。\n优势：\n简单方便，开发量小 前后端原生支持，无需额外第三方库支持 Base64上传 Base64方式上传文件，多常见于小文件，如小图片等，前后端都可直接使用String类型发送和接收。不过在前端，需要将文件转成base64数据，不仅会增加些性能消耗，还会增加传输数据的体积。而对于后端，如果并不是想直接存储base64数据，也还需要将其转成文件再存储，也会增加后端的性能消耗。\n该上传方式可适用于Resetful Api，也可适用于文件的加密、回调接口携带文件等等。其过程如下图所示。\n优势：\n适用于Resetful Api，可用于加密、回调等场景，较为灵活 劣势：\n前后端文件与base64数据转换需要消耗性能 只适用于小文件 OSS直传 此处的OSS直传方案都是使用的阿里云的OSS产品，以下将介绍三个方案，可适用于不同的场景。\nBrowser.js SDK上传 该方案可在前端直接通过browser.js上传文件到OSS，可分成三步：\n前端使用SDK直传OSS 前端上传完成后请求后端，通知上传完成 后端检测OSS上该文件是否存在（可选） 其流程如下图所示。\nBrowser.js的方式需要前端安装阿里云的库ali-oss，然后在前端调用。直传还需要OSS账户的Key和Secret，因此为了安全考虑，需要建立RAM账户，然后前端向后端先请求一个STS临时访问凭证来完成直传，其流程如下图所示。\nJavascript客户端签名直传 Javascript客户端签名直传，需要先从后端获取临时签名，其流程与上一步的browser.js方案大致相同，不同点在于：\n无需第三方库支持，直接表单上传 原生支持后端上传回调（下一步骤讲述） 其流程如下图所示。\n不过该方案做下来，我感觉最大的问题是权限配置有点麻烦\u0026hellip;\u0026hellip;/泪眼\n服务端签名直传并设置上传回调 该方案其实是上面方案——Javascript客户端签名直传的升级版本，其加上了后端的上传回调功能。不错呦～\n前端需要改动的很少，只需要在请求参数中加上callback参数即可，该参数为后端加密，在签名请求的响应中一起返回回来，内加密了后端回调接口。在前端直传完成后，后端回调接口将会接收到相关文件参数，包括文件路径、大小、类型等。最后OSS会将回调接口response转发给前端，响应直传OSS的请求。\n其流程如下图所示。\n对比 传统方式相比直传OSS，相对来说有三个缺点：\n上传慢：用户数据需先上传到应用服务器，之后再上传到OSS。网络传输时间比直传到OSS多一倍。如果用户数据不通过应用服务器中转，而是直传到OSS，速度将大大提升。而且OSS采用BGP带宽，能保证各地各运营商之间的传输速度。 扩展性差：如果后续用户多了，应用服务器会成为瓶颈。 费用高：需要准备多台应用服务器。由于OSS上传流量是免费的，如果数据直传到OSS，不通过应用服务器，那么将能省下几台应用服务器。 当然，对于规模较小、成本较低的项目来说，常见的上传方式还是适合的，毕竟没有最好的，只有最适合的。\n参考文档 Web端上传介绍\nJavaScript客户端签名直传\n服务端签名直传并设置上传回调\n","date":"2021-09-28T09:53:18Z","permalink":"https://blog.hunterji.com/p/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E8%8A%B1%E5%BC%8F%E7%9B%B4%E4%BC%A0oss%E5%90%8E%E7%AB%AF%E9%82%A3%E6%88%91%E8%B5%B0/","title":"前端文件花式直传OSS！后端：那我走？"},{"content":"前言 因为项目需求，需要去检测用户的农历生日。虽然后来找到了合适的库，但是首先先解释下农历的定义，也是去了解才知道，原来农历不是阴历。\n农历属于阴阳合历，其年份分为平年和闰年。平年为十二个月，闰年为十三个月。月份分为大月和小月，大月三十天，小月二十九天，其平均历月等于一个朔望月。\n环境 Go 1.16 github.com/nosixtools/solarlunar 0.0.0 库 1 github.com/nosixtools/solarlunar 该库支持1900~2049年。所以项目要跑到2049年后的童鞋就要注意\u0026hellip;\u0026hellip;\n当然，该库还支持阳历转农历、节假日计算等，有兴趣大家可以自行去了解下。\n使用 判断闰年 该库不支持闰年判断，所以需要自己去实现闰年的判断，其参数类型为Boolean。\n1 2 3 4 5 6 7 func IsALeapYear(year int) (result bool) { if year%4 == 0 \u0026amp;\u0026amp; year%100 != 0 || year%400 == 0 { result = true return } return } 转换 需要转换的阳历日期格式是固定的，是2006-01-02。此处以农历2021-07-17为例。\n1 2 3 4 func main() { lunarDate := \u0026#34;2021-07-17\u0026#34; fmt.Println(solarlunar.LunarToSolar(lunarDate, IsALeapYear(time.Now().Year()))) } 输出为：\n1 2021-08-24 全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/nosixtools/solarlunar\u0026#34; ) func main() { lunarDate := \u0026#34;2021-07-17\u0026#34; fmt.Println(solarlunar.LunarToSolar(lunarDate, IsALeapYear(time.Now().Year()))) } func IsALeapYear(year int) (result bool) { if year%4 == 0 \u0026amp;\u0026amp; year%100 != 0 || year%400 == 0 { result = true return } return } ","date":"2021-08-31T09:08:57Z","permalink":"https://blog.hunterji.com/p/golang%E5%AE%9E%E7%8E%B0%E5%86%9C%E5%8E%86%E8%BD%AC%E6%8D%A2%E9%98%B3%E5%8E%86/","title":"Golang实现农历转换阳历"},{"content":"前言 IOS监听手势使用的方法为UISwipeGestureRecognizer。\n添加手势监听 1 2 3 4 let gesture = UISwipeGestureRecognizer() gesture.addTarget(self, action: #selector(yourSelector(gesture:))) gesture.direction = .left // .left左滑 .right右滑 .up上滑 .down下滑 self.addGestureRecognizer(gesture) 添加响应事件 1 2 3 @objc private func leftPushEvent(){ print(\u0026#34;响应...\u0026#34;) } 模板 把上面的整合起来，基本可以按照这个模板来写。\n1 2 3 4 5 6 7 8 @objc private func leftPushEvent(){ print(\u0026#34;响应...\u0026#34;) } let gesture = UISwipeGestureRecognizer() gesture.addTarget(self, action: #selector(leftPushEvent(gesture:))) gesture.direction = .left self.addGestureRecognizer(gesture) 参考文档 iOS手势识别\u0026ndash;上下左右滑动 ","date":"2021-08-30T14:29:02Z","permalink":"https://blog.hunterji.com/p/ios%E7%9B%91%E5%90%AC%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E6%BB%91%E5%8A%A8%E6%89%8B%E5%8A%BF/","title":"IOS监听上下左右滑动手势"},{"content":"环境 Swift 5.4 Xcode 12.5.1 问题 在使用Swift UI和Realiy开发AR项目时，发现摄像头一直是居中的，无法全屏。\n解决 创建LaunchScreen.storyboard文件 在左侧文件列表中新建文件，名为LaunchScreen.storyboard。\n设置Launch Screen File 点击左侧文件列表中你的项目文件（最顶级文件），进入文件[your-project].xcodeproj文件。\n在General中，找到App Icons and Launch Images，在其模块中有Launch Screen File选项，点击选择为LaunchScreen.storyboard。\n总结下就是：[yourTarget] -\u0026gt; General -\u0026gt; App Icons and Launch Images。\n参考文档 How to make SwiftUI view fullscreen? ","date":"2021-08-30T14:11:58Z","permalink":"https://blog.hunterji.com/p/swiftui-reality%E5%BC%80%E5%8F%91ar%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E5%85%A8%E5%B1%8F%E9%97%AE%E9%A2%98/","title":"SwiftUI+Reality开发AR项目解决全屏问题"},{"content":"问题 开始是开发electron时遇到的问题，使用Interval计时器，在窗口最小化隐藏再打开，计时器在隐藏期间并没有工作。\n后来网上查询相关问题，发现更多是在浏览器tab页隐藏/切换情况下，计时器就会停止。\n解决 在后台选项卡上运行的计时器方法可能会耗尽资源。在后台选项卡中以非常短的时间间隔运行回调的应用程序可能会消耗大量内存，以至于当前活动选项卡的工作可能会受到影响。在最坏的情况下，浏览器可能会崩溃，或者设备的电池会很快耗尽。\n此限制是浏览器限制的。\n无法突破限制，但是可以使用折中的方式，当然我也觉得此方式相较于一直计时会更优，即监听visibilitychange事件。\nvisibilitychange事件可以监听tab页面的激活与失活事件，因此可以：\n在失活时，记录计时器计算的最后的值，清空计时器 在激活时，计算失活期间应有的值，继续使用计时器计算 添加事件代码如下： 1 2 3 4 5 6 7 8 9 10 document.addEventListener(\u0026#39;visibilitychange\u0026#39;, function() { if(document.hidden) { // tab页失活 } else { // tab页激活 } }); 参考文档 https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event\nhttps://usefulangle.com/post/280/settimeout-setinterval-on-inactive-tab\n","date":"2021-08-11T16:20:05Z","permalink":"https://blog.hunterji.com/p/interval%E8%AE%A1%E6%97%B6%E5%99%A8%E5%9C%A8tab%E9%A1%B5%E5%88%87%E6%8D%A2%E6%88%96%E8%80%85%E9%9A%90%E8%97%8F%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C/","title":"Interval计时器在tab页切换或者隐藏情况下停止运行"},{"content":"报错 在Golang中json解析时报错：\n1 invalid character \u0026#39;\\\\b\u0026#39; after top-level value 代码如下：\n1 json.Unmarshal([]byte(result), \u0026amp;response) 分析与排错 首先将result打印出来，发现并无异常，其标点符号也没有问题。\n然后查看网上现有解决方案的帖子基本试了下，起码对于我来说并不适用，概括下方案：\n遍历然后过滤，最后重组； 遍历，使用SetEscapeHTML(false)禁用转义符； 编码； \u0026hellip; 最后对比代码中获取到的字符产长度和手动复制所见的字符串的长度，发现确实代码中字符长度不同，其长度是80，而手动复制的字符串的长度是72。\n解决 1 strings.ReplaceAll(result, \u0026#34;\\b\u0026#34;, \u0026#34;\u0026#34;) 就挺简单的\u0026hellip;\u0026hellip;\n","date":"2021-08-11T13:38:49Z","permalink":"https://blog.hunterji.com/p/go%E4%B8%ADjson%E8%A7%A3%E6%9E%90%E6%8A%A5%E9%94%99invalid-character-%5C%5Cb-after-top-level-value/","title":"go中json解析报错invalid character '\\\\b' after top-level value"},{"content":"前言 项目开发中遇到该问题，网上的文章太乱，为了节省下次踩坑时间，特此记录。\n加解密 填充函数 该函数在加解密中都需要用到。\n1 2 3 4 5 func PKCS5Padding(ciphertext []byte, blockSize int) []byte { padding := blockSize - len(ciphertext)%blockSize padText := bytes.Repeat([]byte{byte(padding)}, padding) return append(ciphertext, padText...) } 加密 1 2 3 4 5 6 7 8 9 10 11 func Ase256Encrypt(plaintext string, key string, iv string, blockSize int) string { bKey := []byte(key) bIV := []byte(iv) bPlaintext := PKCS5Padding([]byte(plaintext), blockSize) block, _ := aes.NewCipher(bKey) ciphertext := make([]byte, len(bPlaintext)) mode := cipher.NewCBCEncrypter(block, bIV) mode.CryptBlocks(ciphertext, bPlaintext) return base64.StdEncoding.EncodeToString(ciphertext) } 解密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func Aes256Decrypt(cryptData, key, iv string) ([]byte, error) { ciphertext, err := base64.StdEncoding.DecodeString(cryptData) if err != nil { return nil, err } block, err := aes.NewCipher([]byte(key)) if err != nil { return nil, err } if len(ciphertext)%aes.BlockSize != 0 { err = errors.New(\u0026#34;ciphertext is not a multiple of the block size\u0026#34;) return nil, err } mode := cipher.NewCBCDecrypter(block, []byte(iv)) mode.CryptBlocks(ciphertext, ciphertext) return ciphertext, err } 全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 填充 func PKCS5Padding(ciphertext []byte, blockSize int) []byte { padding := blockSize - len(ciphertext)%blockSize padText := bytes.Repeat([]byte{byte(padding)}, padding) return append(ciphertext, padText...) } // 加密 func Ase256(plaintext string, key string, iv string, blockSize int) string { bKey := []byte(key) bIV := []byte(iv) bPlaintext := PKCS5Padding([]byte(plaintext), blockSize) block, _ := aes.NewCipher(bKey) ciphertext := make([]byte, len(bPlaintext)) mode := cipher.NewCBCEncrypter(block, bIV) mode.CryptBlocks(ciphertext, bPlaintext) return base64.StdEncoding.EncodeToString(ciphertext) } // 解密 func Aes256Decrypt(cryptData, key, iv string) ([]byte, error) { ciphertext, err := base64.StdEncoding.DecodeString(cryptData) if err != nil { return nil, err } block, err := aes.NewCipher([]byte(key)) if err != nil { return nil, err } if len(ciphertext)%aes.BlockSize != 0 { err = errors.New(\u0026#34;ciphertext is not a multiple of the block size\u0026#34;) return nil, err } mode := cipher.NewCBCDecrypter(block, []byte(iv)) mode.CryptBlocks(ciphertext, ciphertext) return ciphertext, err } 调用 加密 1 result := Ase256Encrypt(\u0026#34;\u0026lt;需要加密的数据\u0026gt;\u0026#34;, \u0026#34;\u0026lt;key\u0026gt;\u0026#34;, \u0026#34;\u0026lt;iv\u0026gt;\u0026#34;, aes.BlockSize) 解密 1 result, err := Aes256Decrypt(\u0026#34;\u0026lt;需要解密的数据\u0026gt;\u0026#34;, \u0026#34;\u0026lt;key\u0026gt;\u0026#34;, \u0026#34;\u0026lt;iv\u0026gt;\u0026#34;) ","date":"2021-08-11T13:13:12Z","permalink":"https://blog.hunterji.com/p/golang-aes-256-cbc%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/","title":"Golang AES-256-CBC加密和解密"},{"content":"问题描述 使用electron开发的windows桌面应用程序，在调用目标文件夹底下的exe执行文件时，开发机子上没有问题，但是其他机子使用时一直调用失败，也抓取不到日志。\n1 2 3 4 5 spawn(path.join(remote.app.getAppPath(), \u0026#34;../target.exe\u0026#34;), [], { shell: true, detached: false, windowsHide: true }); 原因 路径存在空格。\n也是经过各种原因排查，然后一次偶然的成功才注意到了路径问题，排查之后发现确实是这问题\u0026hellip;\u0026hellip;\n解决 spawn按照如上我的代码一定条件下可以运行，其有一个参数cwd，用来表明运行目录。spawn第一个参数必须是命令的名字，不能是路径。\n所以如上代码改成这样：\n1 2 3 4 5 6 spawn(\u0026#34;target.exe\u0026#34;, [], { // 此处直接写目标exe文件 cwd: path.join(remote.app.getAppPath(), \u0026#34;../\u0026#34;), // 注意这里，使用了cwd参数来写运行目录 shell: true, detached: false, windowsHide: true }); 参考文档 node child_process.spawn not working with spaces in path on windows ","date":"2021-07-29T13:49:13Z","permalink":"https://blog.hunterji.com/p/node-spawn%E5%9C%A8windows%E4%B8%8B%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"node spawn在windows下不生效问题记录"},{"content":"问题 使用Alert时，将其用在list的循环视图元素中，弹出Alert时，一定时长不选择就会在点击后弹出第二次。\n这里提一下就是之前在网上看到一个帖子说他将Alert放在NavigationView上也会出现该问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 VStask { ForEach(items, id: \\.self) { item in ElementView(item: item) // 循环中的元素 .alert(isPresented: $showAlert) { Alert( title: Text(\u0026#34;删除确认\u0026#34;), message: Text(\u0026#34;请问您确认删除该数据吗？\u0026#34;), primaryButton: .default( Text(\u0026#34;取消\u0026#34;), action: { showAlert = false } ), secondaryButton: .destructive( Text(\u0026#34;删除\u0026#34;), action: { deleteItems(offsets: [index]) }) ) } } } 解决 将Alert放到循环之前的元素上，比如VStack、List。\n参考 参考帖子 ","date":"2021-07-12T16:40:57Z","permalink":"https://blog.hunterji.com/p/swiftui-macos%E9%A1%B9%E7%9B%AEalert%E5%BC%B9%E5%87%BA%E4%B8%A4%E6%AC%A1%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","title":"SwiftUI MacOS项目alert弹出两次问题解决"},{"content":"实现 1 2 3 4 5 @Environment(\\.colorScheme) var colorScheme var isLight: Bool { colorScheme == .light } 调用 1 2 Text(\u0026#34;Hello, World !\u0026#34;) .foregroundColor(isLight ? Color.red : Color.green) 完整例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import SwiftUI struct CheckIsLight: View { @Environment(\\.colorScheme) var colorScheme var isLight: Bool { colorScheme == .light } var body: some View { Text(\u0026#34;Hello, World !\u0026#34;) .foregroundColor(isLight ? Color.red : Color.green) // 此处使用isLght实现根据暗黑模式切换字体颜色 } } struct CheckIsLight_Previews: PreviewProvider { static var previews: some View { CheckIsLight() } } ","date":"2021-06-08T09:20:38Z","permalink":"https://blog.hunterji.com/p/swiftui%E9%A1%B9%E7%9B%AE%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/","title":"SwiftUI项目判断是否为暗黑模式"},{"content":"设置权限 打开文件info.plist，在空白处右击，选择Add Row，输入选择Privacy - Face ID Usage Description，然后在value中写入我们需要验证您的身份以保护数据。\n代码层面接入 打开ContentView.swift文件，开始如下操作。\n引入相关库 1 import LocalAuthentication 创建lock变量 1 @State private var isUnlocked = false isUnlocked为是否解锁，true表示验证完成，已解锁，false表示验证失败，未解锁。\n创建函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func authenticate() { let context = LAContext() var error: NSError? // 检查生物特征认证是否可用 if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: \u0026amp;error) { // 可用，所以继续使用它 let reason = \u0026#34;我们需要验证您的身份以保护数据\u0026#34; context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in // 身份验证现已完成 DispatchQueue.main.async { if success { // 认证成功，解锁 self.isUnlocked = true } else { // 发生的异常 } } } } else { // 没有生物识别 } } 根据isUnlocked切换View 1 2 3 4 5 6 7 8 VStack { if self.isUnlocked { Text(\u0026#34;Unlocked\u0026#34;) } else { Text(\u0026#34;Locked\u0026#34;) } } .onAppear(perform: authenticate) // 该方法调用生物识别验证函数 审核问题 最近提交了ios和macos两个产品到app store，我设置的强制使用生物识别才能进入应用。但是出现的问题是macos的审核过了，而ios的审核没有过，其反馈的问题即为开始的生物识别没有过，审核人员使用的模拟器，根本不存在生物识别。\n所以跟可能会踩这个坑的小伙伴儿提个醒，目前我还没有好的解决方案，正在等待新的审核中\u0026hellip;\u0026hellip;\n","date":"2021-06-07T17:00:00Z","permalink":"https://blog.hunterji.com/p/swiftui%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%94%A8%E7%94%9F%E7%89%A9%E8%AF%86%E5%88%ABtouch-id--face-id/","title":"SwiftUI项目调用生物识别(Touch ID  --  Face ID)"},{"content":"代码实现 获取屏幕对象 1 var window = NSScreen.main?.visibleFrame 设置大小 1 2 3 4 HStack { } .frame(width: window!.width / 2.0, height: window!.height / 1.5) 汇总 1 2 3 4 5 6 7 8 9 10 11 struct Home: View { var window = NSScreen.main?.visibleFrame var body: some View { HStack { Text(\u0026#34;Hello, World!\u0026#34;) } .frame(width: window!.width / 2.0, height: window!.height / 1.5) } } ","date":"2021-06-07T16:55:50Z","permalink":"https://blog.hunterji.com/p/swiftui-macos%E9%A1%B9%E7%9B%AE%E6%A0%B9%E6%8D%AE%E5%B1%8F%E5%B9%95%E5%A4%A7%E5%B0%8F%E8%B0%83%E6%95%B4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F/","title":"SwiftUI MacOS项目根据屏幕大小调整窗口大小"},{"content":"实现 创建变量 1 @State var search: String = \u0026#34;\u0026#34; 过滤 此处过滤条件为判断元素是否包含搜索的文本。\n1 \u0026lt;Your-Array\u0026gt;.filter({\u0026#34;\\($0)\u0026#34;.contains(search.lowercased()) || search.isEmpty}) 汇总 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct DataList: View { @State var search: String = \u0026#34;\u0026#34; @Binding var dataList: [Item] var dataSearchFilterList: [Item] { dataList.filter({\u0026#34;\\($0)\u0026#34;.contains(search.lowercased()) || search.isEmpty}) } var body: some View { if dataSearchFilterList.isEmpty { Text(\u0026#34;搜索不到...\u0026#34;) } else { ... // 展示搜索结果 } } } ","date":"2021-06-07T16:55:39Z","permalink":"https://blog.hunterji.com/p/swiftui%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/","title":"SwiftUI项目实现搜索功能"},{"content":"前言 swiftui中的点击可以有两种情况：\nButton Gestures 根据不同情况可以去不同地使用。\n单纯的按钮 此处单纯的按钮即为有按钮样式和点击事件。\n1 2 3 4 5 Button(action: { ... // 点击事件触发的代码 }, label: { Image(systemName: \u0026#34;plus\u0026#34;) }) 无样式的按钮 即为没有按钮样式的按钮，方便直接展示Image。\n1 2 3 4 5 6 Button(action: { ... // 点击事件触发的代码 }, label: { Image(systemName: \u0026#34;plus\u0026#34;) }) .buttonStyle(BorderlessButtonStyle()) TapGesture事件 1 2 3 4 Image(systemName: \u0026#34;plus\u0026#34;) .onTapGesture { ... // 点击事件触发的代码 } ","date":"2021-06-07T16:43:17Z","permalink":"https://blog.hunterji.com/p/swiftui%E9%A1%B9%E7%9B%AEimage%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/","title":"SwiftUI项目Image点击事件"},{"content":"前言 这是个比较坑的问题，我一开始开发的是macos项目，到网上搜的方案基本都是使用UIPasteboard方法，但是偏偏用不了。\n后来开发ios项目，用macos的就不行，发现UIPasteboard的可行，所以这里需要清楚的是，ios和macos的复制方法是不同的\u0026hellip;\u0026hellip;\nMacOS 实现 1 2 3 4 5 func copyToClipBoard(textToCopy: String) { let pasteBoard = NSPasteboard.general pasteBoard.clearContents() pasteBoard.setString(textToCopy, forType: .string) } 调用 1 copyToClipBoard(textToCopy: \u0026#34;Hello,World!\u0026#34;) IOS 实现 1 UIPasteboard.general.setValue(\u0026lt;Your-String\u0026gt;, forPasteboardType: kUTTypePlainText as String) 调用 1 UIPasteboard.general.setValue(\u0026#34;Hello,World!\u0026#34;, forPasteboardType: kUTTypePlainText as String) ","date":"2021-06-07T16:29:41Z","permalink":"https://blog.hunterji.com/p/swiftui%E9%A1%B9%E7%9B%AE%E5%A4%8D%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/","title":"SwiftUI项目复制字符串到剪切板"},{"content":"官方方法 DateComponents A date or time specified in terms of units (such as year, month, day, hour, and minute) to be evaluated in a calendar system and time zone.\n以要在日历系统和时区中计算的单位（例如年、月、日、小时和分钟）指定的日期或时间。\n实现 计算两个字符串形式的日期的天数差 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func dateDiff() -\u0026gt; Int { // 计算两个日期差，返回相差天数 let formatter = DateFormatter() let calendar = Calendar.current formatter.dateFormat = \u0026#34;yyyy-MM-dd\u0026#34; let today = Date() // 开始日期 let startDate = formatter.date(from: \u0026#34;2021-06-08\u0026#34;) // 结束日期 let endDate = formatter.date(from: \u0026#34;2021-06-09\u0026#34;) let diff:DateComponents = calendar.dateComponents([.day], from: startDate!, to: endDate!) return diff.day! } 计算当天跟某一天的天数差 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func checkDiff() -\u0026gt; Int { // 计算两个日期差，返回相差天数 let formatter = DateFormatter() let calendar = Calendar.current formatter.dateFormat = \u0026#34;yyyy-MM-dd\u0026#34; // 当天 let today = Date() let startDate = formatter.date(from: formatter.string(from: today)) // 固定日期 let endDate = formatter.date(from: \u0026#34;2021-06-09\u0026#34;) let diff:DateComponents = calendar.dateComponents([.day], from: startDate!, to: endDate!) return diff.day! } ","date":"2021-06-07T15:12:29Z","permalink":"https://blog.hunterji.com/p/swift%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%A9%E6%95%B0%E5%B7%AE/","title":"Swift计算两个日期的天数差"},{"content":"前言 这篇文章是我写的第一篇Swift UI相关的笔记吧。\n这真的难搞哦，毕竟新出来的。国内文档真的是少之又少，国外的文档也真不多，基本搜出来的都是UIKit的。官方文档，也是一言难尽，基本就处于，我要实现一个功能，然后去搜一下各种帖子，筛选掉无用的帖子，找到有用的点，当然也是时常根本找不到有用的帖子，然后就要去油管上看各种教程，然后发现：哦！原来还有这个方法！接着去官方文档搜一下，看一下属性，自己调用调用\u0026hellip;\u0026hellip;\n光是这个core data我就折腾了近一周，最后发现，原来还是官方好呀\u0026hellip;..\n吐槽一下自学swift ui，现在进入正题了。\ncore data呢，是苹果官方的本地数据库，但是其存储的文件其实是sqlite文件。其可以通过icloud实现备份和同步，当然icloud我会额外写一篇文档来详细讲述的（又是一把辛酸泪\u0026hellip;）。\n环境 如下是我当前的环境：\n系统：macOS Big Sur 11.4 Xcode：Version 12.5 (12E262) Swift：5.4 操作步骤 创建项目 在创建项目的时候，可以直接选择Use Core Data选项，xcode会直接在ContentView.swift中生成一个相关demo。\n查看相关文件 创建之后，查看文件目录，相对于不选择Use Core Data，会多出如下几个文件：\n.xcdatamodeId Persistence.swift 创建core data表 点击\u0026lt;Your-Project-Name\u0026gt;.xcdatamodeId文件，进入页面。\n可以看到页面内有默认的CONFIGURATIONS为Default，默认的ENITITIES为Item，可以理解为分别对应sql中的库和表。\n然后点击Item，可以看到其字段，有默认的timestamp字段。\n若要新增ENTITIES（表），点击底部的Add Entity按钮即可。\n若要新增Attributes（字段），点击右侧Attributes中的+即可，注意字段要选择类型。\n比如，此处以默认的Item为例，新增username和age两个字段。\n代码层面操作core data 1）查看 1 2 3 4 5 6 7 8 @Environment(\\.managedObjectContext) private var viewContext @FetchRequest( sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: true)], animation: .default) private var items: FetchedResults\u0026lt;Item\u0026gt; // body中便利items即可 2）新增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private func addItem() { withAnimation { let newItem = Item(context: viewContext) newItem.timestamp = Date() do { try viewContext.save() } catch { // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nsError = error as NSError fatalError(\u0026#34;Unresolved error \\(nsError), \\(nsError.userInfo)\u0026#34;) } } } 如上是xcode自动生成的新增函数，若是要自定义添加字段可以这样改动下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 此处按照如上添加Attributes修改，具体修改按照项目具体情况 private func addItem(username: String, age: Int16) { withAnimation { let newItem = Item(context: viewContext) newItem.username = username newItem.age = age newItem.timestamp = Date() do { try viewContext.save() } catch { // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nsError = error as NSError fatalError(\u0026#34;Unresolved error \\(nsError), \\(nsError.userInfo)\u0026#34;) } } } 3）删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private func deleteItems(offsets: IndexSet) { withAnimation { offsets.map { items[$0] }.forEach(viewContext.delete) do { try viewContext.save() } catch { // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nsError = error as NSError fatalError(\u0026#34;Unresolved error \\(nsError), \\(nsError.userInfo)\u0026#34;) } } } 4）汇总 在默认生成代码中，有一个toolbar，其在macos中可以生效，但是在ios中只有EditionButton()可以使用，为了方便演示，此处新增一个Button来添加数据。\n其次有点要声明下，在xcode中写代码时，右侧的canvas会实时渲染，列表中出现的数据并不是core data中的数据，而是默认生成的Persistence.swift中生成的演示数据，只能看看，不能当真。只有在模拟器/实体机编译运行时才能操作core data。\n如下为修改过后的ContentView.swift文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // // ContentView.swift // HelloKuari // // Created by Kuari on 2021/6/5. // import SwiftUI import CoreData struct ContentView: View { @Environment(\\.managedObjectContext) private var viewContext @FetchRequest( sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: true)], animation: .default) private var items: FetchedResults\u0026lt;Item\u0026gt; var body: some View { VStack { List { ForEach(items) { item in Text(\u0026#34;Tom: \\(item.username!) age: \\(item.age) time : \\(item.timestamp!, formatter: itemFormatter)\u0026#34;) } .onDelete(perform: deleteItems) } // 新增一个按钮来添加数据 Button(action: { addItem(username: \u0026#34;tom\u0026#34;, age: 12) }, label: { Text(\u0026#34;Add Item\u0026#34;) }) } } private func addItem(username: String, age: Int16) { withAnimation { let newItem = Item(context: viewContext) newItem.username = username newItem.age = age newItem.timestamp = Date() do { try viewContext.save() } catch { // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nsError = error as NSError fatalError(\u0026#34;Unresolved error \\(nsError), \\(nsError.userInfo)\u0026#34;) } } } private func deleteItems(offsets: IndexSet) { withAnimation { offsets.map { items[$0] }.forEach(viewContext.delete) do { try viewContext.save() } catch { // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nsError = error as NSError fatalError(\u0026#34;Unresolved error \\(nsError), \\(nsError.userInfo)\u0026#34;) } } } } private let itemFormatter: DateFormatter = { let formatter = DateFormatter() formatter.dateStyle = .short formatter.timeStyle = .medium return formatter }() struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView().environment(\\.managedObjectContext, PersistenceController.preview.container.viewContext) } } 然后点击左侧顶部的运行按钮，编译运行。\n一开始是空白一片，点击Add Item按钮之后，便会开始添加数据。\n对于记录右滑即可删除，其为List的onDelete方法。\n结语 该文章是面向新手的，也是记录下我踩过的坑，因为目前文档匮乏，身边也没swift的开发小伙伴儿，只能靠自己摸索，若有大佬有更好的方法，真的还请不吝赐教。\n后面持续记录踩坑中\u0026hellip;\u0026hellip;\n","date":"2021-06-07T11:24:22Z","permalink":"https://blog.hunterji.com/p/swift-ui%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%94%A8core-data/","title":"Swift UI项目调用core data"},{"content":"简介 要实现h5检测手机摇一摇动作可以直接调用h5原生api。但是在我的实践中发现在ios中限制条件比较多，体验还是有些区别的。\n如何监听 调用Window: devicemotion event即可实现监听。devicemotion事件以固定的时间间隔触发，并指示设备当时在接收的加速物理力量。 它还提供有关旋转速率的信息（如果有）。\n1 2 3 4 5 6 7 8 9 10 function handleMotionEvent(event) { var x = event.accelerationIncludingGravity.x; var y = event.accelerationIncludingGravity.y; var z = event.accelerationIncludingGravity.z; // Do something awesome. } window.addEventListener(\u0026#34;devicemotion\u0026#34;, handleMotionEvent, true); 安卓机 安卓机上直接按照如上即可实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;测试摇一摇\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;show\u0026#34;\u0026gt;摇一摇\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function handleMotionEvent(event) { document.getElementById(\u0026#39;show\u0026#39;).innerHTML = \u0026#39;摇动中\u0026#39; } if (window.DeviceMotionEvent) { window.addEventListener(\u0026#34;devicemotion\u0026#34;, handleMotionEvent, false); } else { alert(\u0026#34;该浏览器不支持摇一摇功能\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; iPhone 限制 在ios上限制有两条：\nh5必须是https协议的 必须用户点击授权才可以调用devicemotion 授权 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function getPermission() { if ( typeof window.DeviceMotionEvent !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; typeof window.DeviceMotionEvent.requestPermission === \u0026#39;function\u0026#39; ) { window.DeviceMotionEvent.requestPermission() .then(function(state) { if (\u0026#39;granted\u0026#39; === state) { //用户同意授权 } else { //用户拒绝授权 alert(\u0026#39;摇一摇需要授权设备运动权限,请重启应用后,再次进行授权!\u0026#39;) } }) .catch(function(err) { alert(\u0026#39;error: \u0026#39; + err) }) } } 直接调用该函数请求授权会导致报错：\n1 error: NotAllowedError: Requesting device orientation or motion access requires a user gesture to prompt 需要用户主动去请求授权，因此此处需要将调用放到比如一个按钮上，让用户去点击请求授权。\n1 \u0026lt;button onclick=\u0026#34;getPermission()\u0026#34;\u0026gt;请求授权\u0026lt;/button\u0026gt; 全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;测试摇一摇\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;getPermission()\u0026#34;\u0026gt;请求授权\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function handleMotionEvent(event) { document.getElementById(\u0026#39;show\u0026#39;).innerHTML = \u0026#39;摇动中\u0026#39; } function startListen() { if (window.DeviceMotionEvent) { window.addEventListener(\u0026#34;devicemotion\u0026#34;, handleMotionEvent, false); } else { alert(\u0026#34;该浏览器不支持摇一摇功能\u0026#34;); } } function getPermission() { if ( typeof window.DeviceMotionEvent !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; typeof window.DeviceMotionEvent.requestPermission === \u0026#39;function\u0026#39; ) { window.DeviceMotionEvent.requestPermission() .then(function(state) { if (\u0026#39;granted\u0026#39; === state) { //用户同意授权 startListen() } else { //用户拒绝授权 alert(\u0026#39;摇一摇需要授权设备运动权限,请重启应用后,再次进行授权!\u0026#39;) } }) .catch(function(err) { alert(\u0026#39;error: \u0026#39; + err) }) } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; ","date":"2021-04-28T13:07:50Z","permalink":"https://blog.hunterji.com/p/h5%E6%A3%80%E6%B5%8B%E6%89%8B%E6%9C%BA%E6%91%87%E4%B8%80%E6%91%87/","title":"H5检测手机摇一摇"},{"content":"简介 具体日志采集方案在Grafana+Loki+Promtail日志收集方案文章中已经介绍过，此处不再重复介绍。不太了解的小伙伴儿赶紧去复习！\n此处主要是记录下Docker Driver Client方式的部署。\ndocker plugin 安装 安装loki插件。\n1 docker plugin install grafana/loki-docker-driver:latest --alias loki --grant-all-permissions 验证 1 2 3 $ docker plugin ls ID NAME DESCRIPTION ENABLED ac720b8fcfdb loki Loki Logging Driver true 开启/禁用 1 2 docker plugin enable loki docker plugin disable loki --force 卸载 1 docker plugin rm loki 部署 docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 version: \u0026#34;3\u0026#34; networks: loki: services: loki: image: grafana/loki:2.0.0 ports: - \u0026#34;3100:3100\u0026#34; command: -config.file=/etc/loki/local-config.yaml networks: - loki grafana: image: grafana/grafana:latest ports: - \u0026#34;3000:3000\u0026#34; networks: - loki 运行 1 docker-compose up -d 容器运行形式 容器运行时需要修改log-driver：\n1 2 3 4 --log-driver=loki --log-opt loki-url=\u0026#34;http://\u0026lt;loki-url\u0026gt;/loki/api/v1/push\u0026#34; --log-opt loki-retries=5 --log-opt loki-batch-size=400 举个例子：\n1 2 3 4 5 6 docker run --log-driver=loki \\ --log-opt loki-url=\u0026#34;http://192.168.10.10:3100/loki/api/v1/push\u0026#34; \\ --log-opt loki-retries=5 \\ --log-opt loki-batch-size=400 \\ -p 3000:3000 \\ nginx 由此查看日志，其labels只有container_name。\n参考文档 官方文档 ","date":"2021-04-14T15:13:18Z","permalink":"https://blog.hunterji.com/p/grafana-loki-docker-driver-client%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%96%B9%E6%A1%88/","title":"Grafana+Loki+Docker Driver Client日志收集方案"},{"content":"前言 简介 Grafana项目由TorkelÖdegaard于2014年发起，最近几年成为GitHub上最受欢迎的开源项目之一。 它使您可以查询，可视化指标并记录警报，无论它们存储在何处。\nLoki是受Prometheus启发的水平可扩展，高度可用的多租户日志聚合系统。 它被设计为非常经济高效且易于操作。 它不索引日志的内容，而是为每个日志流设置一组标签。\nPromtail是将本地日志内容发送到私有Loki实例或Grafana Cloud的代理。 通常将其部署到需要监视应用程序的每台机器上。\n方案对比 为什么选择Grafana + Loki + Promtail的日志采集方案呢？\n我尝试过如下几种方案：\nElasticsearch+Kibana+Filebeat： 运维成本低，侵入性低，但是对于高并发情况下效果不太好，消耗资源也稍高，需要考虑日志存储成本 Elasticsearch+Kibana+Logstash+Kafka+Filebeat: 可以有效处理高并发情况，且在elk节点挂掉情况下不会丢失日志。但是，运维成本高，需要考虑日志存储成本，整套消耗资源比较高！ Grafana+Loki+Docker Driver Client：使用Docker Driver的方式来直接获取容器的日志，配置较简单，但是需要物理机上安装docker plugin，和运行容器时设置log-driver，侵入性较高 相比之下，当前选择的方案，对于我们当前业务场景下是较为合适的，轻量且侵入性低，由于是检测日志文件，无需担心存储成本。\n通用日志收集 首先介绍下通用日志收集版本的部署。只需要使用默认配置即可收集普通日志，可在http://\u0026lt;your-ip\u0026gt;:3000上查看日志详情。\ndocker-compose 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 version: \u0026#34;3\u0026#34; networks: loki: services: loki: image: grafana/loki:2.0.0 ports: - \u0026#34;3100:3100\u0026#34; command: -config.file=/etc/loki/local-config.yaml networks: - loki promtail: image: grafana/promtail:2.0.0 volumes: - /var/log:/var/log command: -config.file=/etc/promtail/config.yml networks: - loki grafana: image: grafana/grafana:latest ports: - \u0026#34;3000:3000\u0026#34; networks: - loki 添加数据源 部署成功之后，打开http://\u0026lt;your-ip\u0026gt;:3000访问Grafana，在左侧菜单栏选择Configuration，默认进去Data Sources页面。\n点击Add data sources按钮，选择Loki。\n填入URL即可，此处为http://loki:3100，具体要看实际部署。\n然后点击Sace \u0026amp; Test添加。\n查看与筛选日志 在左侧菜单栏选择Explore进入页面，点击左上角的Log brwser按钮，可以查看该数据源的labels，如此处为日志文件。\n在页面顶部的输入框中输入官方的LogQL可以筛选日志。此处日志就不展示了，大家知道有就行了。\nDocker容器日志收集 此处详细介绍下关于docker容器日志收集。\npromtail配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ##config.yaml server: http_listen_address: 0.0.0.0 http_listen_port: 9080 positions: filename: /tmp/positions.yaml clients: - url: http://loki:3100/loki/api/v1/push scrape_configs: - job_name: containers static_configs: - targets: - localhost labels: job: containerlogs __path__: /var/lib/docker/containers/*/*log pipeline_stages: - json: expressions: output: log stream: stream attrs: - json: expressions: tag: source: attrs - regex: expression: (?P\u0026lt;container_name\u0026gt;(?:[^|]*[^|])) source: \u0026#34;tag\u0026#34; - timestamp: format: RFC3339Nano source: time - labels: # tag: stream: container_name: - output: source: output docker-compose 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 version: \u0026#34;3\u0026#34; networks: loki: services: loki: image: grafana/loki:2.0.0 ports: - \u0026#34;3100:3100\u0026#34; command: -config.file=/etc/loki/local-config.yaml networks: - loki promtail: image: grafana/promtail:2.0.0 volumes: - /var/lib/docker/containers:/var/lib/docker/containers - ./promtail-config.yaml:/mnt/config/promtail-config.yaml command: -config.file=/mnt/config/promtail-config.yaml networks: - loki grafana: image: grafana/grafana:latest ports: - \u0026#34;3000:3000\u0026#34; networks: - loki 容器日志展现形式 至此其实就已经可以在Grafana上看到当前容器的日志了，操作如上通用日志采集，但是其展现形式只是filename，也就是类似于107728869f40afa5510879a0e372c77bb513d6154591193d375bfcd421357ed4.log的以container_id展现的日志文件，难以辨认具体是哪个容器。（要是有功夫去登录服务器看下容器id，不如直接看下日志了\u0026hellip;）\n所以，为了能够使用容器名去查看日志，此处需要在容器启动时设置参数：\n1 --log-driver json-file --log-opt tag=\u0026#34;{{.Name}}\u0026#34; 举个例子：\n1 docker run --name hello -p 8080:80 --log-driver json-file --log-opt tag=\u0026#34;{{.Name}}\u0026#34; -d nginx 对于使用container name，还有另一种方案，就是每次生成container_name和container_id的映射表，个人认为比较麻烦，有兴趣的小伙伴儿可以尝试下。\n参考文档 Loki官方文档 ruanbekker/promtail_docker_logs Display docker logs with human/logical name ","date":"2021-04-14T14:41:47Z","permalink":"https://blog.hunterji.com/p/grafana-loki-promtail%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%96%B9%E6%A1%88/","title":"Grafana+Loki+Promtail日志收集方案"},{"content":"问题 在使用axios的拦截器时候，需要在request中调用一个promise函数，因此需要等待其执行完成才能去进行下一步。\n1 2 3 4 5 6 7 8 9 function getToken() { return new Promise(...) } // Request interceptors service.interceptors.request.use(config =\u0026gt; { getToken() ... }) 解决 1 2 3 4 5 6 7 8 9 function getToken() { return new Promise(...) } // Request interceptors service.interceptors.request.use(async config =\u0026gt; { awit getToken() ... }) ","date":"2021-04-09T11:06:25Z","permalink":"https://blog.hunterji.com/p/promise-inside-request-interceptor/","title":"Promise inside request interceptor"},{"content":"简介 Rapidly build modern websites without ever leaving your HTML.\nTailwind CSS可以快速建立现代网站，而无需离开HTML。其特性是原子化，很像的BootStrap的css。\n通俗点解释就是，其封装了很多独立的css样式，只需要在html中添加class即可调用，而不需要去从头写css样式。\n安装 下载包 1 npm install tailwindcss@latest postcss@latest autoprefixer@latest 可能会遇到如下报错：\n1 Error: PostCSS plugin tailwindcss requires PostCSS 8. 那就需要降低PostCSS的版本。如下，先卸载，再去安装。\n1 2 npm uninstall tailwindcss postcss autoprefixer npm install tailwindcss@npm:@tailwindcss/postcss7-compat @tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9 添加Tailwind作为PostCSS插件 添加tailwindcss和autoprefixer到PostCSS配置。大部分情况下作为postcss.config.js文件放在项目的顶级路径下。其也能作为.postcssrc文件，或者使用postcss键放在package.json文件中。\n1 2 3 4 5 6 7 // postcss.config.js module.exports = { plugins: { tailwindcss: {}, autoprefixer: {}, } } 创建配置文件 如果想自定义安装，当使用npm安装tailwindcss时候需要使用tailwind命令行去生成一个配置文件。\n1 npx tailwindcss init 这将会创建一个最小化的tailwind.config.js文件，其位于项目的顶级路径下。\n1 2 3 4 5 6 7 8 9 10 // tailwind.config.js module.exports = { purge: [], darkMode: false, // or \u0026#39;media\u0026#39; or \u0026#39;class\u0026#39; theme: { extend: {}, }, variants: {}, plugins: [], } 在CSS中包含Tailwind 创建styles.css文件。\n1 2 3 4 /* ./your-css-folder/styles.css */ @tailwind base; @tailwind components; @tailwind utilities; 引入该文件。\n1 import \u0026#34;./styles.css\u0026#34; 构建CSS 为生产而构建时，确保配置清除选项以删除任何最小文件大小的未使用类。\n1 2 3 4 5 6 7 8 9 10 11 12 // tailwind.config.js module.exports = { purge: [\u0026#34;./index.html\u0026#34;, \u0026#34;./src/**/*.{vue,js,ts,jsx,tsx}\u0026#34;], // 修改此行 darkMode: false, // or \u0026#39;media\u0026#39; or \u0026#39;class\u0026#39; theme: { extend: {} }, variants: { extend: {} }, plugins: [] }; 简要说明 由于其样式属性巨多，此处只举几例作简要说明，讲解基础用法。在开始不熟悉的情况下，要开着其手册查询。\nWidth Class 解释 w-0 width: 0px; w-1 width: 0.25rem; w-1/2 width: 50%; w-full width: 100%; \u0026hellip; \u0026hellip; 1 2 3 4 \u0026lt;!--示例--\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;w-1/2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; Padding Class 解释 p-0 padding: 0px; p-5 padding: 1.25rem; pl-1 padding-left: 0.25rem; \u0026hellip; \u0026hellip; 1 2 \u0026lt;!--示例--\u0026gt; \u0026lt;div class=\u0026#34;p-5\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Position Class 解释 static position: static; fixed position: fixed; absolute position: absolute; \u0026hellip; \u0026hellip; 1 2 3 4 5 6 7 \u0026lt;!--示例--\u0026gt; \u0026lt;div class=\u0026#34;static\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Static parent\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;absolute bottom-0 left-0 ...\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Absolute child\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; Flex垂直居中 1 2 3 4 5 \u0026lt;div class=\u0026#34;flex flex-row justify-center items-center\u0026#34;\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 简单案例 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div class=\u0026#34;flex flex-col justify-center items-center p-20\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;item in 10\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;flex flex-row justify-between items-center w-1/5 bg-gray-100 m-5 p-10 cursor-pointer shadow rounded hover:shadow-lg transition duration-300 ease-in-out\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;@/assets/message.png\u0026#34; alt=\u0026#34;logo\u0026#34; height=\u0026#34;50px\u0026#34; width=\u0026#34;50px\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col ml-5\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;text-lg\u0026#34;\u0026gt;今天晚上加{{ item }}个鸡腿\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text-sm text-gray-500\u0026#34;\u0026gt;2020.2.{{ item }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ","date":"2021-02-05T11:16:28Z","permalink":"https://blog.hunterji.com/p/tailwindcss%E5%9F%BA%E7%A1%80/","title":"tailwindcss基础"},{"content":"前言 为什么要用sqlx而不是gorm呢？是因为orm学习成本比较高，当使用python时候需要使用sqlalchemy，遇到go就要换成gorm，换成别的语言就又有其他orm。而直接使用原生sql可以减少学习成本，适用于所有开发语言。其次，gorm本身支持软删除，但是其对软删除的支持上存在缺陷，在单条查询可以过滤软删除数据，但是在多条查询时无法有效过滤，就造成了有时候要手动过滤又有时候不要手动过滤，使用体验非常差。\n因此此处考虑去使用sqlx来直接调用原生sql。\n安装 1 go get github.com/jmoiron/sqlx 连接数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package database import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; \u0026#34;github.com/jmoiron/sqlx\u0026#34; ) func DBConnect() *sqlx.DB { env := os.Getenv(\u0026#34;NODE_ENV\u0026#34;) var host, port, user, password, dbname string // 使用环境变量来切换生产和开发环境 if env == \u0026#34;production\u0026#34; { host = os.Getenv(\u0026#34;dbHost\u0026#34;) port = os.Getenv(\u0026#34;dbPort\u0026#34;) user = os.Getenv(\u0026#34;dbUser\u0026#34;) password = os.Getenv(\u0026#34;dbPassword\u0026#34;) dbname = os.Getenv(\u0026#34;dbname\u0026#34;) } else { host = \u0026#34;\u0026lt;your-host\u0026gt;\u0026#34; port = \u0026#34;\u0026lt;your-port\u0026gt;\u0026#34; user = \u0026#34;\u0026lt;your-user\u0026gt;\u0026#34; password = \u0026#34;\u0026lt;your-password\u0026gt;\u0026#34; dbname = \u0026#34;\u0026lt;your-db-name\u0026gt;\u0026#34; } dbConfig := fmt.Sprintf(\u0026#34;%s:%s@tcp(%s:%s)/%s?parseTime=true\u0026#34;, user, password, host, port, dbname) db, err := sqlx.Connect(\u0026#34;mysql\u0026#34;, dbConfig) if err != nil { fmt.Println(err) panic(\u0026#34;failed to connect database\u0026#34;) } return db } 创建表和调用 创建表 1 2 3 4 5 6 7 8 9 10 11 create table if not exists test_gin.todo ( todo_id int auto_increment primary key, title varchar(20) not null comment \u0026#39;todo标题\u0026#39;, content varchar(200) null comment \u0026#39;内容\u0026#39;, user_id int not null comment \u0026#39;用户id\u0026#39;, created_at timestamp default CURRENT_TIMESTAMP null comment \u0026#39;创建时间戳\u0026#39;, updated_at timestamp default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment \u0026#39;更新时间戳\u0026#39;, is_deleted tinyint(1) default 0 not null comment \u0026#39;是否被删除,0:未删,1:已删\u0026#39; ); 创建struct 1 2 3 4 5 6 7 8 9 type Todo struct { TodoID int `db:\u0026#34;todo_id\u0026#34; json:\u0026#34;todo_id,omitempty\u0026#34;` Title string `db:\u0026#34;title\u0026#34; json:\u0026#34;title,omitempty\u0026#34;` Content string `db:\u0026#34;content\u0026#34; json:\u0026#34;content,omitempty\u0026#34;` UserID int `db:\u0026#34;user_id\u0026#34; json:\u0026#34;user_id,omitempty\u0026#34;` CreatedAt string `db:\u0026#34;created_at\u0026#34; json:\u0026#34;created_at,omitempty\u0026#34;` UpdatedAt string `db:\u0026#34;updated_at\u0026#34; json:\u0026#34;updated_at,omitempty\u0026#34;` IsDeleted bool `db:\u0026#34;is_deleted\u0026#34; json:\u0026#34;is_deleted,omitempty\u0026#34;` } 封装方法 此处以增删为例。封装常用方法是为了复用，封装时候使用害羞的代码。不需要为了封装而封装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 新增Todo func (t *Todo) Add() (todoID int, err error) { // 连接数据库 db := database.DBConnect() defer db.Close() // 执行添加sql tx := db.MustBegin() result := tx.MustExec(\u0026#34;insert into todo (title, content, user_id) value (?, ?, ?)\u0026#34;, t.Title, t.Content, t.UserID) lastTodoID, err := result.LastInsertId() if err != nil { return } _ = tx.Commit() todoID = int(lastTodoID) return } // 删除Todo func (t *Todo) Del() { db := database.DBConnect() defer db.Close() tx := db.MustBegin() tx.MustExec(\u0026#34;update todo set is_deleted = 0 where is_deleted = 0 and todo_id = ?\u0026#34;, t.TodoID) _ = tx.Commit() } 视图中使用 此处以新增接口为例。\n调用封装的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package views import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;testGin/models\u0026#34; ) // addTodo.go -- post func AddTodo(c *gin.Context) { // {\u0026#34;title\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;world\u0026#34;} var requestBody struct { Title string `json:\u0026#34;title\u0026#34;` Content string `json:\u0026#34;content\u0026#34;` } if c.ShouldBind(\u0026amp;requestBody) != nil { c.JSON(200, gin.H{ \u0026#34;code\u0026#34;: 40000, \u0026#34;message\u0026#34;: \u0026#34;参数有误\u0026#34;, }) return } todo := models.Todo{ Title: requestBody.Title, Content: requestBody.Content, UserID: 1, // 此处的1为假数据，此处应当从上下文获取请求用户的user_id } todoID, err := todo.Add() if err != nil { c.JSON(200, gin.H{ \u0026#34;code\u0026#34;: 20001, }) return } c.JSON(200, gin.H{ \u0026#34;code\u0026#34;: 20000, \u0026#34;todo_id\u0026#34;: todoID, }) } 直接使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package views import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;testGin/database\u0026#34; ) // addTodo.go -- post func AddTodo(c *gin.Context) { // {\u0026#34;title\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;world\u0026#34;} var requestBody struct { Title string `json:\u0026#34;title\u0026#34;` Content string `json:\u0026#34;content\u0026#34;` } if c.ShouldBind(\u0026amp;requestBody) != nil { c.JSON(200, gin.H{ \u0026#34;code\u0026#34;: 40000, \u0026#34;message\u0026#34;: \u0026#34;参数有误\u0026#34;, }) return } // 连接数据库 db := database.DBConnect() defer db.Close() // 执行添加sql tx := db.MustBegin() result := tx.MustExec(\u0026#34;insert into todo (title, content, user_id) value (?, ?, ?)\u0026#34;, requestBody.Title, requestBody.Content, 1) lastTodoID, err := result.LastInsertId() if err != nil { c.JSON(200, gin.H{ \u0026#34;code\u0026#34;: 20001, }) return } _ = tx.Commit() c.JSON(200, gin.H{ \u0026#34;code\u0026#34;: 20000, \u0026#34;todo_id\u0026#34;: int(lastTodoID), }) } ","date":"2020-12-25T12:51:12Z","permalink":"https://blog.hunterji.com/p/sqlx%E5%BB%BA%E6%A8%A1%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/","title":"sqlx建模、连接与使用"},{"content":"前言 gin的中间件的使用场景非常广泛，此处主要介绍如何使用其来完成常见场景下的鉴权。\n官方文档 官方文档列出了如下几种使用方式：\n使用中间件 定制中间件 使用基础认证的中间件 中间件使用协程 不同场景的鉴权实现 api key 对于api key的方式需要设置白名单，对白名单外的请求进行token检测。此中间件在处理请求被处理之前对请求进行拦截，验证token，因此可在此处利用gin.Context来设置上下文，如请求所属用户的用户信息等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package middleware import ( \u0026#34;fmt\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func whiteList() map[string]string { return map[string]string{ \u0026#34;/ping\u0026#34;: \u0026#34;GET\u0026#34;, } } func withinWhiteList(url *url.URL, method string) bool { target := whiteList() queryUrl := strings.Split(fmt.Sprint(url), \u0026#34;?\u0026#34;)[0] if _, ok := target[queryUrl]; ok { if target[queryUrl] == method { return true } return false } return false } func Authorize() gin.HandlerFunc { return func(c *gin.Context) { type QueryToken struct { Token string `binding:\u0026#34;required,len=3\u0026#34; form:\u0026#34;token\u0026#34;` } // 当路由不在白名单内时进行token检测 if !withinWhiteList(c.Request.URL, c.Request.Method) { var queryToken QueryToken if c.ShouldBindQuery(\u0026amp;queryToken) != nil { c.AbortWithStatusJSON(200, gin.H{ \u0026#34;code\u0026#34;: 40001, }) return } c.Set(\u0026#34;role\u0026#34;, \u0026#34;user\u0026#34;) } c.Next() } } 路由权限 1）说明 对于请求的处理，需要去验证是否对其请求的路径拥有访问权限。\n首先看一下gin的路由设置：\n1 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes 其参数为...HandlerFunc，其解释为：\n1 2 type HandlerFunc func(*Context) HandlerFunc defines the handler used by gin middleware as return value. 所以此处可以通过定制中间件的方式实现一个路由权限处理。\n当然此处的权限处理比较简单，使用角色直接去判断权限。如分为两个角色，管理员admin和普通用户user。\n不过此处实现有个前提条件，就是如何拿到用户的角色呢？此处需要在上一步（api key）的实现中加上利用gin.Context设置角色：\n1 c.Set(\u0026#34;role\u0026#34;, \u0026#34;admin\u0026#34;) // 可见上一步的代码，当然此处只是为了演示设置固定值 然后在中间件中拿到角色并进行判断。\n2）路由权限中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package middleware import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func Permissions(roles []string) gin.HandlerFunc { return func(c *gin.Context) { permissionsErr := func() error { // 获取上下文中的用户角色 roleValue, exists := c.Get(\u0026#34;role\u0026#34;) if !exists { return errors.New(\u0026#34;获取用户信息失败\u0026#34;) } role := fmt.Sprint(roleValue) // 判断请求的用户的角色是否属于设定角色 noAccess := true for i := 0; i \u0026lt; len(roles); i++ { if role == roles[i] { noAccess = false } } if noAccess { return errors.New(\u0026#34;权限不够\u0026#34;) } return nil }() if permissionsErr != nil { c.AbortWithStatusJSON(200, gin.H{ \u0026#34;code\u0026#34;: 40001, }) return } c.Next() } } 3）使用 在设置路由时候，添加该中间件，并设置白名单。\n1 2 r.POST(\u0026#34;/todo\u0026#34;, middleware.Permissions([]string{\u0026#34;admin\u0026#34;}), views.AddTodo) // 添加中间件将会验证角色 r.PUT(\u0026#34;/todo\u0026#34;, views.ModifyTodo) // 未添加中间件则不会验证角色 ","date":"2020-12-18T14:02:30Z","permalink":"https://blog.hunterji.com/p/gin%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E9%89%B4%E6%9D%83/","title":"gin中间件和鉴权"},{"content":"前言 在数据量较小的情况下，可以使用Redis来实现消息的发布与订阅，来代替Kafka。Kafka对于数据量大的场景下性能卓越，但是对于如此小场景时候，不仅运维成本提升，还用不上多少性能。\n不过使用Redis的另一个弊端是消息不能堆积，一旦消费者节点没有消费消息，消息将会丢失。因此需要评估当下场景来选择适合的架构。\n此处使用go-redis来实现Redis的发布与订阅。\n官方文档 官方文档有较为完整的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 pubsub := rdb.Subscribe(ctx, \u0026#34;mychannel1\u0026#34;) // Wait for confirmation that subscription is created before publishing anything. _, err := pubsub.Receive(ctx) if err != nil { panic(err) } // Go channel which receives messages. ch := pubsub.Channel() // Publish a message. err = rdb.Publish(ctx, \u0026#34;mychannel1\u0026#34;, \u0026#34;hello\u0026#34;).Err() if err != nil { panic(err) } time.AfterFunc(time.Second, func() { // When pubsub is closed channel is closed too. _ = pubsub.Close() }) // Consume messages. for msg := range ch { fmt.Println(msg.Channel, msg.Payload) } 代码实现 分步讲解下具体实现代码。\n连接redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func redisConnect() (rdb *redis.Client) { var ( redisServer string port string password string ) redisServer = os.Getenv(\u0026#34;RedisUrl\u0026#34;) port = os.Getenv(\u0026#34;RedisPort\u0026#34;) password = os.Getenv(\u0026#34;RedisPass\u0026#34;) rdb = redis.NewClient(\u0026amp;redis.Options{ Addr: redisServer + \u0026#34;:\u0026#34; + port, Password: password, DB: 0, // use default DB }) return } 发布消息 1 2 3 4 func pubMessage(channel, msg string) { rdb := redisConnect() rdb.Publish(context.Background(), channel, msg) } 订阅消息 1 2 3 4 5 6 7 8 9 10 11 12 13 func subMessage(channel string) { rdb := redisConnect() pubsub := rdb.Subscribe(context.Background(), channel) _, err := pubsub.Receive(context.Background()) if err != nil { panic(err) } ch := pubsub.Channel() for msg := range ch { fmt.Println(msg.Channel, msg.Payload) } } 完整案例 此处分为一个发布节点和一个订阅节点来实现了简单的发布与订阅。\n消息发布节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-redis/redis/v8\u0026#34; ) func redisConnect() (rdb *redis.Client) { var ( redisServer string port string password string ) redisServer = os.Getenv(\u0026#34;RedisUrl\u0026#34;) port = os.Getenv(\u0026#34;RedisPort\u0026#34;) password = os.Getenv(\u0026#34;RedisPass\u0026#34;) rdb = redis.NewClient(\u0026amp;redis.Options{ Addr: redisServer + \u0026#34;:\u0026#34; + port, Password: password, DB: 0, // use default DB }) return } func pubMessage(channel, msg string) { rdb := redisConnect() rdb.Publish(context.Background(), channel, msg) } func main() { channel := \u0026#34;hello\u0026#34; msgList := []string{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // 此处发了两个消息 for _, msg := range msgList { pubMessage(channel, msg) fmt.Printf(\u0026#34;已经发送%s到%s\\n\u0026#34;, msg, channel) } } 消息订阅节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-redis/redis/v8\u0026#34; ) func redisConnect() (rdb *redis.Client) { var ( redisServer string port string password string ) redisServer = os.Getenv(\u0026#34;RedisUrl\u0026#34;) port = os.Getenv(\u0026#34;RedisPort\u0026#34;) password = os.Getenv(\u0026#34;RedisPass\u0026#34;) rdb = redis.NewClient(\u0026amp;redis.Options{ Addr: redisServer + \u0026#34;:\u0026#34; + port, Password: password, DB: 0, // use default DB }) return } func subMessage(channel string) { rdb := redisConnect() pubsub := rdb.Subscribe(context.Background(), channel) _, err := pubsub.Receive(context.Background()) if err != nil { panic(err) } ch := pubsub.Channel() for msg := range ch { fmt.Println(msg.Channel, msg.Payload) } } func main() { channel := \u0026#34;hello\u0026#34; subMessage(channel) } 运行结果 消息发布节点输出 消息订阅节点输出 ","date":"2020-11-27T17:41:53Z","permalink":"https://blog.hunterji.com/p/go-redis%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/","title":"go-Redis的发布与订阅"},{"content":"前言 想要写出好的 Go 程序，单元测试是很重要的一部分。 testing 包为提供了编写单元测试所需的工具，写好单元测试后，可以通过 go test 命令运行测试。\n规则 testing 为 Go 语言 package 提供自动化测试的支持。通过 go test 命令，能够自动执行如下形式的任何函数：\n1 func TestXxx(*testing.T) 要编写一个新的测试套件，需要创建一个名称以 _test.go 结尾的文件，该文件包含 TestXxx 函数，如上所述。 将该文件放在与被测试文件相同的包中。该文件将被排除在正常的程序包之外，但在运行 go test 命令时将被包含。\n代码结构 1 2 3 4 5 . ├── go.mod ├── intMinBasicDriven_test.go ├── intMinBasic_test.go └── main.go 第一个单元测试 要被测试的代码 1 2 3 4 5 6 7 8 9 10 11 // main.go package main func IntMin(a, b int) int { // 返回a与b中的较小值 if a \u0026lt; b { return a } else { return b } } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 // intMinBasic_test.go package main import \u0026#34;testing\u0026#34; func TestIntMinBasic(t *testing.T) { ans := IntMin(2, -2) if ans != -2 { // t.Error* 会报告测试失败的信息，然后继续运行测试。 // t.Fail* 会报告测试失败的信息，然后立即终止测试。 t.Errorf(\u0026#34;IntMin(2, -2) = %d; want -2\u0026#34;, ans) } } 运行测试 1 2 3 go test // 输出 ok heihei\t0.385s Table-Driven Test 单元测试可以重复，所以会经常使用 表驱动 风格编写单元测试， 表中列出了输入数据，预期输出，使用循环，遍历并执行测试逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // intMinBasicDriven_test.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; ) func TestIntMinTableDriven(t *testing.T) { var tests = []struct { a, b int want int }{ {0, 1, 0}, {1, 0, 0}, {2, -2, -2}, {0, -1, -1}, {-1, 0, -1}, } // t.Run 可以运行一个 “subtests” 子测试，一个子测试对应表中一行数据。 运行 go test -v 时，他们会分开显示。 for _, tt := range tests { testname := fmt.Sprintf(\u0026#34;%d,%d\u0026#34;, tt.a, tt.b) t.Run(testname, func(t *testing.T) { ans := IntMin(tt.a, tt.b) if ans != tt.want { t.Errorf(\u0026#34;got %d, want %d\u0026#34;, ans, tt.want) } }) } } 运行代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 go test -v // 输出 === RUN TestIntMinTableDriven === RUN TestIntMinTableDriven/0,1 === RUN TestIntMinTableDriven/1,0 === RUN TestIntMinTableDriven/2,-2 === RUN TestIntMinTableDriven/0,-1 === RUN TestIntMinTableDriven/-1,0 --- PASS: TestIntMinTableDriven (0.00s) --- PASS: TestIntMinTableDriven/0,1 (0.00s) --- PASS: TestIntMinTableDriven/1,0 (0.00s) --- PASS: TestIntMinTableDriven/2,-2 (0.00s) --- PASS: TestIntMinTableDriven/0,-1 (0.00s) --- PASS: TestIntMinTableDriven/-1,0 (0.00s) PASS ok heihei\t0.566s ","date":"2020-11-20T15:07:06Z","permalink":"https://blog.hunterji.com/p/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","title":"go单元测试"},{"content":"前言 Go 标准库专门提供了 net/http/httptest 包专门用于进行 http Web 开发测试。\n此处基于gin来实现http的单元测试。\nGET请求 此处使用http单元测试对/ping请求测试，其正常会返回字符串pong，响应码为200。\nweb应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main func setupRouter() *gin.Engine { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) return r } func main() { r := setupRouter() r.Run(\u0026#34;:8080\u0026#34;) } http单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;net/http\u0026#34; \u0026#34;net/http/httptest\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; ) func TestPingRoute(t *testing.T) { router := setupRouter() // 创建http server并发起请求 w := httptest.NewRecorder() req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/ping\u0026#34;, nil) router.ServeHTTP(w, req) assert.Equal(t, 200, w.Code) // 断言响应码为200 assert.Equal(t, \u0026#34;pong\u0026#34;, w.Body.String()) // 断言响应为\u0026#34;pong\u0026#34; } POST/PUT/DELETE请求 post、put、delete请求处理相似，都是处理其request body，因此此处只以post为例。\n此处对/todo进行测试，其正常返回为json，其中code为20000，响应码为200。\nweb应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main func setupRouter() *gin.Engine { r := gin.Default() r.POST(\u0026#34;/todo\u0026#34;, func(c *gin.Context) { type ToDo struct { TodoId int `binding:\u0026#34;required\u0026#34; json:\u0026#34;todo_id\u0026#34;` } var todo ToDo if err := c.ShouldBindJSON(\u0026amp;todo); err != nil { c.JSON(400, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;参数不全\u0026#34;, }) return } // 处理代码，此处以打印为例，省略处理... fmt.Println(todo.TodoId) c.JSON(200, gin.H{ \u0026#34;code\u0026#34;: 20000, }) }) return r } func main() { r := setupRouter() r.Run(\u0026#34;:8080\u0026#34;) } http单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main func TestTodoCreate(t *testing.T) { // 请求方法 method := \u0026#34;POST\u0026#34; // 请求路由 urlStr := \u0026#34;/todo\u0026#34; // request body body := map[string]interface{}{ \u0026#34;title\u0026#34;: \u0026#34;hello\u0026#34;, } jsonByte, _ := json.Marshal(body) req := httptest.NewRequest(method, tc.urlStr, bytes.NewReader(jsonByte)) w := httptest.NewRecorder() router := routers.SetupRouter() router.ServeHTTP(w, req) assert.Equal(t, 200, w.Code) // 判断响应码 var response map[string]int json.Unmarshal([]byte(w.Body.String()), \u0026amp;response) value, exits := response[\u0026#34;code\u0026#34;] assert.True(t, exits) assert.Equal(t, 20000, value) // 判断自定义状态码 } 封装测试请求 由于http单元测试代码中存在较多重复，因此此处封装重复代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package tests type TestConfig struct { Url string Method string Body interface{} } func (tc *TestConfig) Request() *httptest.ResponseRecorder { var req *http.Request if tc.Body != nil { jsonByte, _ := json.Marshal(tc.Body) req = httptest.NewRequest(tc.Method, tc.Url, bytes.NewReader(jsonByte)) } else { req = httptest.NewRequest(tc.Method, tc.Url, nil) } w := httptest.NewRecorder() router := routers.SetupRouter() router.ServeHTTP(w, req) return w } 封装后的单元测试 此处以post请求为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main func TestAddTag(t *testing.T) { // 新增tag var addTestConfig tests.TestConfig addTestConfig.Method = \u0026#34;POST\u0026#34; addTestConfig.Url = \u0026#34;/tag\u0026#34; addTestConfig.Body = map[string]string{ \u0026#34;tag_name\u0026#34;: \u0026#34;HelloHello\u0026#34;, } w := addTestConfig.Request() assert.Equal(t, 200, w.Code) var addResponse map[string]int json.Unmarshal([]byte(w.Body.String()), \u0026amp;addResponse) value, exits := addResponse[\u0026#34;code\u0026#34;] assert.True(t, exits) assert.Equal(t, 20000, value) lastInsertTagId, exits := addResponse[\u0026#34;tag_id\u0026#34;] assert.True(t, exits) } ","date":"2020-11-20T14:47:04Z","permalink":"https://blog.hunterji.com/p/gin%E7%9A%84http%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","title":"gin的http单元测试"},{"content":"前言 代码运行过程中，意外情况会导致500错误，对于使用者来说体验很不好，对于开发者来说也无法及时获取错误，需要去查看日志。\n并且有的插件在某些报错情况下会返回一些敏感信息，非常危险。因此需要去捕获全局错误，通知开发者，自定义错误消息等。\n实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from server import app from flask import request from datetime import datetime from werkzeug.exceptions import HTTPException @app.errorhandler(Exception) def all_exception_handler(e): if isinstance(e, HTTPException): if e.code == 404: return { \u0026#39;code\u0026#39;: 40004, \u0026#39;message\u0026#39;: \u0026#39;404\u0026#39; }, 404 # 通知开发者/写入日志 handle(path = request.path, content = str(e)) return { \u0026#39;code\u0026#39;: 20001, \u0026#39;message\u0026#39;: \u0026#39;Error\u0026#39; } ","date":"2020-11-02T20:51:02Z","permalink":"https://blog.hunterji.com/p/flask%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/","title":"Flask设置全局错误捕获"},{"content":"前言 当前产品遇到一个报错，就是接口收到请求没有限制请求字段长度，导致字段长度超过数据库对应字段长度，直接报了500。因此也对此有些新的需求，需要在后端限制请求字段最大长度。\n环境 开发语言：Python 3.7 后端框架：Flask 1.1.1 插件：Flask-RESTful 0.3.8 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 def field_max_limit(max_length): def validate(s): if type(s) != str: raise ValidationError(\u0026#34;The field must be String.\u0026#34;) if len(s) \u0026lt;= max_length: return s raise ValidationError(\u0026#34;The field cannot exceed %i characters.\u0026#34; % max_length) return validate # 解析请求参数时候验证长度 parse.add_argument(\u0026#39;username\u0026#39;, type = field_max_limit(5), required = True) 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from flask import Flask from flask_restful import Api, Resource, reqparse from werkzeug.routing import ValidationError app = Flask(__name__) api = Api(app) def field_max_limit(max_length): def validate(s): if type(s) != str: raise ValidationError(\u0026#34;The field must be String.\u0026#34;) if len(s) \u0026lt;= max_length: return s raise ValidationError(\u0026#34;The field cannot exceed %i characters.\u0026#34; % max_length) return validate class Login(Resource): def post(self): parse = reqparse.RequestParser() parse.add_argument(\u0026#39;username\u0026#39;, type = field_max_limit(5), required = True) parse.add_argument(\u0026#39;password\u0026#39;, type = field_max_limit(20), required = True) args = parse.parse_args() print({ \u0026#39;username\u0026#39;: args.username, \u0026#39;password\u0026#39;: args.password }) return { \u0026#39;code\u0026#39;: 20000 } api.add_resource(Login, \u0026#39;/login\u0026#39;) ","date":"2020-11-02T20:24:35Z","permalink":"https://blog.hunterji.com/p/flask_restful%E9%99%90%E5%88%B6request%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/","title":"flask_restful限制request字段长度"},{"content":"前言 在使用Docker时，其默认时区并非使用者所在时区，需要进行修改。对于单个容器，当前修改有几种常见方式，比如直接映射宿主机时区到容器内，而本文介绍的为使用Dockerfile来直接修改镜像时区。此处仅以常见几个基础容器为例来介绍。\n常见容器 Alpine 1 2 3 4 5 6 7 FROM alpine:latest # 安装tzdata RUN apk add --no-cache tzdata # 设置时区 ENV TZ=\u0026#34;Asia/Shanghai\u0026#34; 验证 1 2 docker build -t alpine:time . docker run --rm -it alpine:time date Ubuntu 1 2 3 4 5 6 7 8 9 10 FROM ubuntu # 设置localtime # 此处需要优先设置localtime，否则安装tzdata将会进入时区选择 RUN ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 安装tzdata RUN apt-get update \\ \u0026amp;\u0026amp; apt-get install tzdata -y \\ \u0026amp;\u0026amp; apt-get clean 验证 1 2 docker build -t ubuntu:time . docker run --rm -it ubuntu:time date Debian Debian中已经安装了tzdata，所以跟Ubuntu有所不通过 1 2 3 4 5 6 7 8 9 10 11 FROM debian # 修改设置dpkg为自动配置 ENV DEBIAN_FRONTEND=noninteractive RUN ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime RUN dpkg-reconfigure -f noninteractive tzdata # 修改设置dpkg为手动输入选择操作 ENV DEBIAN_FRONTEND=dialog 验证 1 2 docker build -t debian:time . docker run --rm -it debian:time date 结语 此处不再列举太多，主要解决方式为安装tzdata，然后修改时区。\n","date":"2020-10-14T23:21:39Z","permalink":"https://blog.hunterji.com/p/docker%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/","title":"Docker修改时区"},{"content":"简述 在特定敏感数据的场景需要加密，一开始采用rsa加密，但是rsa加密对性能要求较高，在解密时候对于数据量限制较大，导致加密传输的数据量上限较低。而采用Base64虽然简单明了但是解密过于简单。因此采用折中的对称加密aes。\n而aes加密需要前后端加密类型相同，因此此处采用CTR，其对加密文本没有长度限制。\n前端实现 1 2 3 4 5 6 7 let crypto = require(\u0026#34;crypto\u0026#34;) export function aesEncrypted(key, text) { let iv = Buffer.concat([ crypto.randomBytes(12), Buffer.alloc(4, 0) ]) let cipher = crypto.createCipheriv(\u0026#34;aes-128-ctr\u0026#34;, key, iv) return iv.toString(\u0026#39;hex\u0026#39;) + cipher.update(text, \u0026#39;utf8\u0026#39;, \u0026#39;hex\u0026#39;) + cipher.final(\u0026#39;hex\u0026#39;) } 后端实现 1 2 3 4 5 6 7 8 9 10 11 def aesDecryption(key_: str, de_text: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; aes解密函数 :param key_: aes的key :param de_text: aes加密的密文 :return: 解密的文本 \u0026#34;\u0026#34;\u0026#34; ct = codecs.decode(de_text.encode(), \u0026#39;hex\u0026#39;) counter = Counter.new(32, prefix = ct[:12], initial_value = 0) cipher = AES.new(key_.encode(), AES.MODE_CTR, counter = counter) return cipher.decrypt(ct[16:]).decode() 示例代码 前端 1 2 3 4 5 6 7 let crypto = require(\u0026#34;crypto\u0026#34;) export function aesEncrypted(key, text) { let iv = Buffer.concat([ crypto.randomBytes(12), Buffer.alloc(4, 0) ]) let cipher = crypto.createCipheriv(\u0026#34;aes-128-ctr\u0026#34;, key, iv) return iv.toString(\u0026#39;hex\u0026#39;) + cipher.update(text, \u0026#39;utf8\u0026#39;, \u0026#39;hex\u0026#39;) + cipher.final(\u0026#39;hex\u0026#39;) } 后端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from base64 import b64encode from Crypto.Cipher import AES from Crypto.Util import Counter from random import randint import codecs import hashlib def convert_to_md5(info: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; md5加密 :param info: 需要加密的内容 :return: md5加密密文 \u0026#34;\u0026#34;\u0026#34; md5 = hashlib.md5() md5.update(info.encode(\u0026#39;utf-8\u0026#39;)) return md5.hexdigest() def aesCreateKey() -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; 生成aes加密的key，key的长度必须16位 :return: 返回key的base64密文 \u0026#34;\u0026#34;\u0026#34; en_key = convert_to_md5(str(randint(100000, 999999)))[8:-8] return b64encode(en_key.encode()).decode() def aesDecryption(key_: str, de_text: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; aes解密函数 :param key_: aes的key :param de_text: aes加密的密文 :return: 解密的文本 \u0026#34;\u0026#34;\u0026#34; ct = codecs.decode(de_text.encode(), \u0026#39;hex\u0026#39;) counter = Counter.new(32, prefix = ct[:12], initial_value = 0) cipher = AES.new(key_.encode(), AES.MODE_CTR, counter = counter) return cipher.decrypt(ct[16:]).decode() 参考文档 https://stackoverflow.com/questions/44996742/encrypt-with-node-js-aes-ctr-and-decrypt-with-pycrypto ","date":"2020-10-09T21:12:50Z","permalink":"https://blog.hunterji.com/p/%E5%9F%BA%E4%BA%8Epython3%E5%92%8Cjs%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AFaes%E5%8A%A0%E8%A7%A3%E5%AF%86/","title":"基于python3和js的前后端aes加解密"},{"content":"报错 1 an upstream response is buffered to a temporary file 解决 Nginx配置加上如下配置\n1 2 proxy_max_temp_file_size 0; client_max_body_size 50m; ","date":"2020-08-15T22:07:58Z","permalink":"https://blog.hunterji.com/p/nginx%E6%8A%A5%E9%94%99an-upstream-response-is-buffered-to-a-temporary-file/","title":"nginx报错an upstream response is buffered to a temporary file"},{"content":"前言 对于Golang操作Redis，此处使用github.com/go-redis/redis。\n操作 连接redis服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package redis import ( \u0026#34;context\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/go-redis/redis/v8\u0026#34; jsoniter \u0026#34;github.com/json-iterator/go\u0026#34; ) var ctx = context.Background() func BaseClient() (rdb *redis.Client) { redisServer := \u0026#34;redis_server\u0026#34; port := \u0026#34;redis_port\u0026#34; password := \u0026#34;redis_password\u0026#34; rdb = redis.NewClient(\u0026amp;redis.Options{ Addr: redisServer + \u0026#34;:\u0026#34; + port, Password: password, DB: 0, }) return } ###存储\n1 2 3 4 5 6 func SetJson(key string, value map[string]interface{}, expiration int) (err error) { rdb := BaseClient() valueString, _ := jsoniter.MarshalToString(value) err = rdb.Set(ctx, key, valueString, time.Duration(expiration)*time.Second).Err() return } 调用 1 2 3 4 5 6 7 func main() { value, _ := redis.SetJson(\u0026#34;user\u0026#34;, map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;age\u0026#34;: 12 }), 60, } ###读取\n1 2 3 4 5 func Get(key string) (value string, err error) { rdb := BaseClient() value, err = rdb.Get(ctx, key).Result() return } 调用 1 2 3 4 5 6 7 8 9 10 11 12 13 type User struct { Name\tstring Age\tint } func main() { value, _ := redis.Get(\u0026#34;user\u0026#34;) var user User json.Unmarshal([]byte(value), \u0026amp;user) fmt.Print(user) } 结语 使用JSON格式存储与读取其实就是对目标数据在存储前和读取后进行格式转换。\n","date":"2020-08-11T18:42:42Z","permalink":"https://blog.hunterji.com/p/golang%E4%BD%BF%E7%94%A8json%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%8F%96redis/","title":"Golang使用JSON格式存取Redis"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;math/rand\u0026#34; \u0026#34;strconv\u0026#34; ) func CreateVerifyCode() (verifyCode string) { min := 100000 max := 999999 verifyCode = strconv.Itoa(rand.Intn(max-min) + min) return } ","date":"2020-08-11T09:08:20Z","permalink":"https://blog.hunterji.com/p/go%E7%94%9F%E6%88%906%E4%BD%8D%E9%9A%8F%E6%9C%BA%E6%95%B0/","title":"Go生成6位随机数"},{"content":"报错 按照ElementUI官方文档按需引入却报错，首先报错缺少babel-preset-es2015。安装该组件之后编译却报错。\n1 Error: Plugin/Preset files are not allowed to export objects, only functions. 解决 该问题为babel版本冲突。\n安装插件 1 yarn add @babel/preset-env 编辑.babelrc 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;presets\u0026#34;: [[\u0026#34;@babel/preset-env\u0026#34;, { \u0026#34;modules\u0026#34;: false }]], \u0026#34;plugins\u0026#34;: [ [ \u0026#34;component\u0026#34;, { \u0026#34;libraryName\u0026#34;: \u0026#34;element-ui\u0026#34;, \u0026#34;styleLibraryName\u0026#34;: \u0026#34;theme-chalk\u0026#34; } ] ] } ","date":"2020-08-10T00:00:54Z","permalink":"https://blog.hunterji.com/p/vue%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5elementui%E6%8A%A5%E9%94%99error--plugin--preset-files-are-not-allowed-to-export-objects-only-functions/","title":"Vue按需引入ElementUI报错Error --  Plugin -- Preset files are not allowed to export objects, only functions"},{"content":"前言 Flask_RESTful是一个Flask 扩展，它添加了快速构建 REST APIs 的支持。其请求解析接口是模仿 argparse 接口。它设计成提供简单并且统一的访问 Flask 中 flask.request 对象里的任何变量的入口。\n常见类型解析 基本参数 请求 1 2 3 4 { \u0026#34;username\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;info\u0026#34;: \u0026#34;heihei\u0026#34; } 解析 1 2 3 4 parse = reqparse.RequestParser() parse.add_argument(\u0026#39;username\u0026#39;, type = str) parse.add_argument(\u0026#39;info\u0026#39;, type = str) args = parse.parse_args() 必选参数 使用参数required。\n请求 1 2 3 4 { \u0026#34;username\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;info\u0026#34;: \u0026#34;heihei\u0026#34; } 解析 1 2 3 4 parse = reqparse.RequestParser() parse.add_argument(\u0026#39;username\u0026#39;, type = str, required = True) parse.add_argument(\u0026#39;info\u0026#39;, type = str, required = True) args = parse.parse_args() 列表[string] 使用参数action = 'append'\n请求 1 2 3 4 5 6 { \u0026#34;username\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;info\u0026#34;: [ \u0026#34;handsome\u0026#34;, \u0026#34;cheerful\u0026#34;, \u0026#34;optimism\u0026#34; ] } 解析 1 2 3 4 parse = reqparse.RequestParser() parse.add_argument(\u0026#39;username\u0026#39;, type = str, required = True) parse.add_argument(\u0026#39;info\u0026#39;, type = str, action = \u0026#39;append\u0026#39;, required = True) args = parse.parse_args() 列表[dict] 使用参数action = 'append'\n请求 1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;username\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;friends\u0026#34;: [ { \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;age\u0026#34;: 20 }, { \u0026#34;username\u0026#34;: \u0026#34;jerry\u0026#34;, \u0026#34;age\u0026#34;: 20 } ] } 解析 1 2 3 4 parse = reqparse.RequestParser() parse.add_argument(\u0026#39;username\u0026#39;, type = str, required = True) parse.add_argument(\u0026#39;info\u0026#39;, type = dict, action = \u0026#39;append\u0026#39;, required = True) args = parse.parse_args() JSON 请求 1 2 3 4 5 6 7 { \u0026#34;username\u0026#34;: \u0026#34;kuari\u0026#34;, \u0026#34;info\u0026#34;: { \u0026#34;character\u0026#34;: \u0026#34;optimism\u0026#34;, \u0026#34;age\u0026#34;: 20 } } 解析 1 2 3 4 parse = reqparse.RequestParser() parse.add_argument(\u0026#39;username\u0026#39;, type = str, required = True) parse.add_argument(\u0026#39;info\u0026#39;, type = dict, required = True) args = parse.parse_args() ","date":"2020-08-05T15:49:56Z","permalink":"https://blog.hunterji.com/p/flask_restful%E8%A7%A3%E6%9E%90%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/","title":"Flask_RESTful解析常见类型请求数据"},{"content":"报错 在Go中POST请求时报错\n1 x509: certificate signed by unknown authority 即无法检验证书。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;net/http\u0026#34; ) func Handle() { ... _, err := http.Post( ... ) ... } 解决 跳过校验即可。此处引入\u0026quot;crypto/tls\u0026quot;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;crypto/tls\u0026#34; \u0026#34;net/http\u0026#34; ) func Handle() { ... tr := \u0026amp;http.Transport{ TLSClientConfig: \u0026amp;tls.Config{InsecureSkipVerify: true}, } client := \u0026amp;http.Client{ Timeout: 15 * time.Second, Transport: tr, } _, err := client.Post( ... ) ... } ","date":"2020-08-04T09:58:55Z","permalink":"https://blog.hunterji.com/p/go-http%E8%AF%B7%E6%B1%82%E6%8A%A5%E9%94%99x509-certificate-signed-by-unknown-authority/","title":"Go http请求报错x509 certificate signed by unknown authority"},{"content":"前言 部署SFTP服务器，数次遇到几个报错，特此记录\n环境 路径\n1 2 3 home └── tom └── uploads 用户为tom\n报错 报错一 1 permission denied 报错二 1 bad ownership or modes for chroot directory component \u0026#34;/home\u0026#34; 解决 以上两个报错，此处为统一解决。\n创建用户组 1 groupadd ftp 将用户加入用户组 1 usermod -a -G ftp tom 设置权限 1 2 3 chown root:ftp -R /home/tom chown tom:ftp -R /home/tom/uploads chmod 755 -R /home ","date":"2020-07-23T16:56:30Z","permalink":"https://blog.hunterji.com/p/sftp%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/","title":"SFTP部署报错解决记录"},{"content":"一对多 1 2 3 4 5 6 7 8 9 10 class Country(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(30), unique=True) capital = db.relationship(\u0026#39;Capital\u0026#39;, uselist=False) class Capital(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(30), unique=True) country_id = db.Column(db.Integer, db.ForeignKey(\u0026#39;country.id\u0026#39;)) country = db.relationship(\u0026#39;Country\u0026#39;) 一对多 1 2 3 4 5 6 7 8 9 class Author(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) phone = db.Column(db.String(20)) class Article(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(50), index=True) body =\tdb.Column(db.Text) 多对一 1 2 3 4 5 6 7 8 9 class Citizen(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) city_id = db.Column(db.Integer, db.ForeignKey(\u0026#39;city.id\u0026#39;)) city = db.relationship(\u0026#39;City\u0026#39;) class City(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(30), unique=True) 多对多 1 2 3 4 5 6 7 8 9 10 11 12 13 association_table = db.Table(\u0026#39;association\u0026#39;,db.Column(\u0026#39;student_id\u0026#39;, db.Integer, db.Foreign) class Student(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) grade = db.Column(db.String(20)) teachers = db.relationship(\u0026#39;Teacher\u0026#39;, secondary=association_table, back_populates=\u0026#39;students\u0026#39;) class Teacher(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) office = db.Column(db.String(20)) ","date":"2020-06-23T13:46:21Z","permalink":"https://blog.hunterji.com/p/flask_sqlalchemy%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%A4%9A%E5%AF%B9%E5%A4%9A/","title":"flask_sqlalchemy一对一、一对多、多对一、多对多"},{"content":"问题 使用docker运行的wordpress，有报错The uploaded file exceeds the upload_max_filesize directive in php.ini。\n过程 按照一般的方式去修改文件php.ini：\n1 2 upload_max_filesize = 30M post_max_size = 30M 容器中有两个php.ini文件：\nphp.ini-development php.ini-production 都修改之后却并不生效。\n解决 在文件夹conf.d中添加文件uploads.ini：\n1 2 3 4 5 file_uploads = On memory_limit = 64M upload_max_filesize = 64M post_max_size = 64M max_execution_time = 600 文件夹conf.d位置需要看具体环境：\n1 php -i | grep php.ini 然后在其目录下找到文件夹conf.d。\n也可以通过在运行容器时候直接将该文件映射进入。\n","date":"2020-06-03T15:35:33Z","permalink":"https://blog.hunterji.com/p/docker%E4%B8%ADphp%E4%B8%8A%E4%BC%A0%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/","title":"docker中php上传大小限制"},{"content":"需求 Linux对于开发者来说极其友好，但是由于国内主流办公产品相关的生态较为匮乏，因此如何使用Linux去分享文件是一件十分头疼的问题。\n对于这个问题，可以直接使用静态文件服务器解决部分需求，如下介绍几个常见方法。\n语言类 Python 对于Python来说，可以直接使用内置的库来实现。\npython2\n1 python -m SimpleHTTPServer 8000 Python3\n1 python -m http.server 8000 Node.js node生态内有一个项目http-server，直接V8引擎带你飞。\n安装 Npm 1 npm install --global http-server Homebrew 1 brew install http-server 运行 1 http-server [path] [options] 例如：\n1 2 cd exmaple/ http-server 项目仓库地址 https://github.com/http-party/http-server\n服务类 Nginx/Apache Nginx和Apache本身可用于静态文件服务器，这就需要用户直接在本地安装。\n当然，nginx需要注意配置一下，打开索引：\n1 2 3 4 5 6 7 8 9 server { listen\t80; ... location / { root /usr/share/nginx/html; autoindex on; } } Docker 使用Docker其实也是使用如Nginx来实现静态文件服务器，但是容器化在该场景存在几大优势：\n即开即用 环境隔离 相对于直接安装Nginx或者Apache，更推荐使用Docker。\n","date":"2020-06-02T19:05:56Z","permalink":"https://blog.hunterji.com/p/linux%E5%88%86%E4%BA%AB%E6%96%87%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"Linux分享文件？快速创建静态文件服务器"},{"content":"介绍 为了前后端传输数据的安全性，需要对数据进行加密。因此选定使用非对称加密，此处为RSA。\n在传输数据前，后端生成公钥和私钥，将公钥给前端，前端加密之后，将密文传给后端，后端使用私钥解密即可得到原始的数据。\n环境 前端使用jsencrypt加密 后端使用Crypto生成密钥和解密 后端生成密钥 1 2 3 4 5 6 7 8 9 10 11 12 from Crypto.PublicKey import RSA def generate_key(): \u0026#34;\u0026#34;\u0026#34; 生成公钥和私钥 :return: 返回私钥和公钥 \u0026#34;\u0026#34;\u0026#34; rsa = RSA.generate(1024) private_key = rsa.exportKey() publick_key = rsa.publickey().exportKey() return private_key.decode(), publick_key.decode() 前端用公钥加密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { JSEncrypt } from \u0026#34;jsencrypt\u0026#34;; function rsa_en(pubkey, target_str) { /** 分段加密信息 :params target_str: 需要加密的信息，此处为很长的信息 :pubkey: 公钥 :return: 存储密文的数组 **/ let encrypt = new JSEncrypt(); encrypt.setPublicKey(pubkey); let result = encrypt.encrypt(JSON.stringify(target_str)); } 后端使用私钥解密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 from Crypto.Hash import SHA from Crypto import Random from base64 import b64decode def rsa_decrypt(private_key, message): \u0026#34;\u0026#34;\u0026#34; rsa解密函数 :prams private_key: 私钥 :params message: 加密后的密文 :return: 解密后原始信息 \u0026#34;\u0026#34;\u0026#34; dsize = SHA.digest_size sentinel = Random.new().read(1024 + dsize) private_key = RSA.import_key(private_key) cipher_rsa = PKCS1_v1_5.new(private_key) return cipher_rsa.decrypt(b64decode(message), sentinel) 这里使用base64先解密一遍是必要的，否则报错ValueError: Ciphertext with incorrect length. 完整代码 前端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { JSEncrypt } from \u0026#34;jsencrypt\u0026#34;; function rsa_en(pubkey, target_str) { /** 分段加密信息 :params target_str: 需要加密的信息，此处为很长的信息 :pubkey: 公钥 :return: 存储密文的数组 **/ let encrypt = new JSEncrypt(); encrypt.setPublicKey(pubkey); let result = encrypt.encrypt(JSON.stringify(target_str)); } 后端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 from Crypto.Hash import SHA from Crypto import Random from base64 import b64decode def generate_key(): \u0026#34;\u0026#34;\u0026#34; 生成公钥和私钥 :return: 返回私钥和公钥 \u0026#34;\u0026#34;\u0026#34; rsa = RSA.generate(1024) private_key = rsa.exportKey() publick_key = rsa.publickey().exportKey() return private_key.decode(), publick_key.decode() def rsa_encrypt(public_key, message): \u0026#34;\u0026#34;\u0026#34; rsa加密函数 :params publick_key: 公钥 :params message: 需要加密的信息 :return: 加密后的密文 \u0026#34;\u0026#34;\u0026#34; public_key = RSA.import_key(public_key) cipher_rsa = PKCS1_v1_5.new(public_key) return cipher_rsa.encrypt(str.encode(message)) def rsa_decrypt(private_key, message): \u0026#34;\u0026#34;\u0026#34; rsa解密函数 :prams private_key: 私钥 :params message: 加密后的密文 :return: 解密后原始信息 \u0026#34;\u0026#34;\u0026#34; dsize = SHA.digest_size sentinel = Random.new().read(1024 + dsize) private_key = RSA.import_key(private_key) cipher_rsa = PKCS1_v1_5.new(private_key) return cipher_rsa.decrypt(b64decode(message), sentinel) 分段加密 RSA加密信息最长为128位，过长则会报错，因此，对于过长的信息需要分段加密，后端也要分段解密后拼装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { JSEncrypt } from \u0026#34;jsencrypt\u0026#34;; function en_str(target_str, pubkey) { /** 分段加密信息 :params target_str: 需要加密的信息，此处为很长的信息 :pubkey: 公钥 :return: 存储密文的数组 **/ let encrypt = new JSEncrypt(); encrypt.setPublicKey(pubkey); let en_array = []; let n = 100; // 每段信息的长度 for (let i = 0, l = target_str.length; i \u0026lt; l / n; i++) { let message = target_str.slice(n * i, n * (i + 1)); en_array.push(encrypt.encrypt(message)); } return en_array; } ","date":"2020-05-22T15:11:05Z","permalink":"https://blog.hunterji.com/p/vue-flask%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","title":"vue+flask前后端信息传输非对称加密"},{"content":"场景 使用 v-charts 做数据可视化，需要给图表添加标题。\n解决方法 v-charts本身并没有提供显示标题的配置，顾需要引入 echarts 的 title 。\n实现 引入title 1 import \u0026#34;echarts/lib/component/title\u0026#34;; 添加标题配置 1 2 3 4 5 6 7 this.chartTitle = { text: \u0026#34;平台用户与创客数量对比图\u0026#34;, textStyle: { fontWeight: 600, color: \u0026#34;white\u0026#34; } }; 使用 1 \u0026lt;ve-bar :title=\u0026#34;chartTitle\u0026#34; /\u0026gt; 完整实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;ve-bar ... :title=\u0026#34;chartTitle\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import \u0026#34;echarts/lib/component/title\u0026#34;; export default { data() { this.chartTitle = { text: \u0026#34;平台用户与创客数量对比图\u0026#34;, textStyle: { fontWeight: 600, color: \u0026#34;white\u0026#34; } }; } }; \u0026lt;/script\u0026gt; echarts配置手册 https://www.echartsjs.com/zh/option.html#title 参考文章 https://github.com/ElemeFE/v-charts/issues/191 ","date":"2020-03-26T14:54:27Z","permalink":"https://blog.hunterji.com/p/v-charts%E6%B7%BB%E5%8A%A0%E5%9B%BE%E8%A1%A8%E6%A0%87%E9%A2%98/","title":"v-charts添加图表标题"},{"content":"在vue2中不允许子组件直接修改props，为单项数据流，所有若要修改只能通过额外的值，并监听props以改变额外的值。\n设置props 1 2 3 4 5 6 props: { dialog: { type: Boolean, default: false } } 创建额外的值 在data中创建一个localDialog，其值为this.dialog。\n1 2 3 4 5 data() { return { localDialog: this.dialog } } 监听 保持同步的关键在于需要在子组件内监听props，即此处的dialog。\n1 2 3 4 5 watch: { dialog(val) { this.localDialog = val } } 子组件向父组件传递 子组件使用this.$emit()即可向父组件传递变化的值。\n1 2 3 4 5 methods: { sendToFather() { this.$emit(\u0026#39;dialogchange\u0026#39;, this.localDialog) } } 父组件调用 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;your-component :dialog=\u0026#34;dialog\u0026#34; @dialogchange=\u0026#34;dialogchange\u0026#34; /\u0026gt; data() { return { dialog: false } }, methods: { dialogchange(val) { this.dialog = val } } 完整代码 子组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div :visible=\u0026#34;localDialog\u0026#34;\u0026gt; hunterji.com \u0026lt;button @click=\u0026#34;sendToFather\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { dialog: { type: Boolean, default: false } }, data() { return { localDialog: this.dialog } }, watch: { dialog(val) { this.localDialog = val } }, methods: { sendToFather() { this.$emit(\u0026#39;dialogchange\u0026#39;, this.localDialog) } } } \u0026lt;/script\u0026gt; 父组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;your-component :dialog=\u0026#34;dialog\u0026#34; @dialogchange=\u0026#34;dialogchange\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import yourComponent from \u0026#39;./yourComponent\u0026#39; export default { components: { yourComponent }, data() { return { dialog: false } }, methods: { dialogchange(val) { this.dialog = val } } } \u0026lt;/script\u0026gt; ","date":"2020-03-21T23:48:37Z","permalink":"https://blog.hunterji.com/p/vue%E7%BB%84%E4%BB%B6props%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/","title":"vue组件props双向绑定"},{"content":"增 1 2 3 article = Article(title=\u0026#39;article1\u0026#39;, content=\u0026#39;heihei\u0026#39;) db.session.add(article) db.session.commit() 若要在新增之后获取数据库中新增数据的信息，如id。\n1 2 3 4 5 6 7 8 article = Article(title=\u0026#39;article1\u0026#39;, content=\u0026#39;heihei\u0026#39;) db.session.add(article) db.session.flush() # 添加这一条，用于预提交 db.session.commit() # 输出新增数据的信息 print(article.id) print(article.title) 删 1 2 3 4 5 6 7 8 ##把需要删除的数据查找出来 article = Article.query.filter_by(content = \u0026#39;heihei\u0026#39;).first() ##把这条数据删除掉 db.session.delete(article) ##提交 db.session.commit() 改 1 2 3 4 5 6 7 8 ##先把你要更改的数据查找出来 article = Article.query.filter(Article.title == \u0026#39;article1\u0026#39;).first() ##把这条数据需要修改的地方进行修改 article.title = \u0026#39;article2\u0026#39; ##提交 db.session.commit() 查 查询单个 1 2 3 4 5 article1 = Article.query.filter(Article.title == \u0026#39;article\u0026#39;).first() article1 = Article.query.filter_by(title = \u0026#39;article\u0026#39;).first() # 或者 print(article1.title) print(article1.content) 查询所有 1 2 3 4 article1 = Article.query.filter_by(title = \u0026#39;article\u0026#39;).all() for item in article1: print(item.title) print(item.content) 倒叙 1 article1 = Article.query.filter_by(title = \u0026#39;article\u0026#39;).order_by(Article.id.desc()).all() 限制数量 1 article1 = Article.query.filter_by(title = \u0026#39;article\u0026#39;).limit(10).all() ","date":"2020-03-20T12:19:52Z","permalink":"https://blog.hunterji.com/p/flask_sqlalchemy%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"Flask_sqlalchemy的增删改查"},{"content":"场景 前端导入excel表格，直接前端解析文件，将数据传给后端。\n需要的库 安装 1 npm install xlsx 使用 1 import XLSX from \u0026#34;xlsx\u0026#34;; 代码实现 html部分 1 2 3 4 5 6 7 8 9 10 \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; {{ upload_file || \u0026#34;导入\u0026#34; }} \u0026lt;input type=\u0026#34;file\u0026#34; accept=\u0026#34;.xls,.xlsx\u0026#34; class=\u0026#34;upload_file\u0026#34; @change=\u0026#34;readExcel($event)\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; JS部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 readExcel(e) { // 读取表格文件 let that = this; const files = e.target.files; if (files.length \u0026lt;= 0) { return false; } else if (!/\\.(xls|xlsx)$/.test(files[0].name.toLowerCase())) { this.$message({ message: \u0026#34;上传格式不正确，请上传xls或者xlsx格式\u0026#34;, type: \u0026#34;warning\u0026#34; }); return false; } else { // 更新获取文件名 that.upload_file = files[0].name; } const fileReader = new FileReader(); fileReader.onload = ev =\u0026gt; { try { const data = ev.target.result; const workbook = XLSX.read(data, { type: \u0026#34;binary\u0026#34; }); const wsname = workbook.SheetNames[0]; //取第一张表 const ws = XLSX.utils.sheet_to_json(workbook.Sheets[wsname]); //生成json表格内容 console.log(ws); } catch (e) { return false; } }; fileReader.readAsBinaryString(files[0]); } 整体代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; {{ upload_file || \u0026#34;导入\u0026#34; }} \u0026lt;input type=\u0026#34;file\u0026#34; accept=\u0026#34;.xls,.xlsx\u0026#34; class=\u0026#34;upload_file\u0026#34; @change=\u0026#34;readExcel($event)\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import XLSX from \u0026#34;xlsx\u0026#34;; export default { data() { return { upload_file: \u0026#34;\u0026#34;, lists: [] }; }, methods: { submit_form() { // 给后端发送请求，更新数据 console.log(\u0026#34;假装给后端发了个请求...\u0026#34;); }, readExcel(e) { // 读取表格文件 let that = this; const files = e.target.files; if (files.length \u0026lt;= 0) { return false; } else if (!/\\.(xls|xlsx)$/.test(files[0].name.toLowerCase())) { this.$message({ message: \u0026#34;上传格式不正确，请上传xls或者xlsx格式\u0026#34;, type: \u0026#34;warning\u0026#34; }); return false; } else { // 更新获取文件名 that.upload_file = files[0].name; } const fileReader = new FileReader(); fileReader.onload = ev =\u0026gt; { try { const data = ev.target.result; const workbook = XLSX.read(data, { type: \u0026#34;binary\u0026#34; }); const wsname = workbook.SheetNames[0]; //取第一张表 const ws = XLSX.utils.sheet_to_json(workbook.Sheets[wsname]); //生成json表格内容 that.lists = []; // 从解析出来的数据中提取相应的数据 ws.forEach(item =\u0026gt; { that.lists.push({ username: item[\u0026#34;用户名\u0026#34;], phone_number: item[\u0026#34;手机号\u0026#34;] }); }); // 给后端发请求 this.submit_form(); } catch (e) { return false; } }; fileReader.readAsBinaryString(files[0]); } } }; \u0026lt;/script\u0026gt; 样式 原本的文件上传样式可能会跟页面整体风格不搭，所以需要修改其样式。不过此处并不是直接修改其样式而是通过写一个div来覆盖原有的上传按钮。此处样式与element UI中的primary按钮样式相同。\n实现该样式的关键在于.upload_file的opacity和position。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 .container { border: none; border-radius: 4px; background-color: #409eff; height: 40px; margin-top: 8px; display: flex; align-items: center; justify-content: center; padding: 0 15px; min-width: 80px; *zoom: 1; } .upload_file { font-size: 20px; opacity: 0; position: absolute; filter: alpha(opacity=0); width: 60px; } 最后 前端的日益强大导致很多功能都可以在前端去直接实现，并且可以减少服务器压力。\n当然单纯地去实现这样的数据传输，尤其对于重要数据，是很不安全的，因此在前后端数据传输的时候，可以加上加密校验，这个后期会来写的。\n参考文章 为了实现该功能参考了如下大佬的文章：\n【Vue 笔记】Vue 读取excel数据并生成数组 vue前端导入并解析excel表格操作指南 css input[type=file] 样式美化，input上传按钮美化 ","date":"2020-03-19T13:11:01Z","permalink":"https://blog.hunterji.com/p/vue%E5%AE%9E%E7%8E%B0%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AF%BC%E5%85%A5%E4%B8%8E%E8%A7%A3%E6%9E%90excel%E8%A1%A8%E6%A0%BC%E6%96%87%E4%BB%B6/","title":"vue实现纯前端导入与解析excel表格文件"},{"content":"报错 使用flask_sqlalchemy，服务端出现500错误，日志显示报错如下：\n1 MySQL server has gone away 解决 添加配置:\n1 SQLALCHEMY_POOL_RECYCLE = 280 该配置作用是设置多少秒后回收连接，如果不提供值，默认为 2 小时。此处将其设置为280秒。\n该配置原文解释：\nNumber of seconds after which a connection is automatically recycled. This is required for MySQL, which removes connections after 8 hours idle by default. Note that Flask-SQLAlchemy automatically sets this to 2 hours if MySQL is used.\n","date":"2020-03-12T21:44:36Z","permalink":"https://blog.hunterji.com/p/flask_sqlalchemy%E6%8A%A5%E9%94%99mysql-server-has-gone-away%E8%A7%A3%E5%86%B3/","title":"Flask_sqlalchemy报错MySQL server has gone away解决"},{"content":"Restful作为目前流行的api设计规范，在flask上也有较好的实践，即为flask_restful。我们在使用flask_restful的时候，当代码量达到一定程度，需要将视图函数模块化。然而在Flask之前一直使用Blueprint模块化，那么flask_restful如何模块化呢？底下就来瞅瞅！\n当前架构 1 2 3 4 5 server/ ├── __init__.py ├── commands.py ├── config.py └── views.py __init__.py：将该文件夹标示为一个模块 commands.py：额外命令，如初始化数据库 config.py：配置文件 views.py：视图函数 此为一个简单的flask项目架构，我们可以将flask中的各个功能拆分出来，分给不同文件，最后在__init__.py导入。\n1 2 3 4 5 6 7 8 9 10 11 12 from flask import Flask from flask_cors import CORS from flask_restful import Api app = Flask(\u0026#39;server\u0026#39;) app.config.from_pyfile(\u0026#39;config.py\u0026#39;) CORS(app) api = Api(app) from server import commands, views 初步模块化 现在将视图函数改为一个文件夹views，然后在该文件夹下放入拆分后的文件。这里以登录和获取用户信息接口为例，架构就变成了下面这样。\n1 2 3 4 5 6 7 8 server/ ├── __init__.py ├── commands.py ├── config.py └── views ├── __init__.py ├── login.py └── info.py 此处的__init__.py文件功能如上，是将文件夹views标示为模块，但是此处的__init__py是个空白文件，但是server文件夹中的__init__.py的引入需要改变。\n1 2 3 ... from server import commands from server.views import login, info 最终模块化 此时还不够，例如登录和获取用户信息接口是User模块下的，而获取文章标题接口是Article模块的下的，因此我们继续分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 server/ ├── __init__.py ├── commands.py ├── config.py └── views ├── Aricle │ ├── __init__.py │ └── title.py ├── User │ ├── __init__.py │ ├── info.py │ └── login.py └── __init__.py server文件夹中的__init__.py的引入继续改变。\n1 2 3 4 ... from server import commands from server.views.User import login, info from srever.views.Article import title 结语 至此，关于flask_restful的视图函数模块化结束，若有后续改进会继续分享，若大家有更好的方式请务必分享一下。\n当时为了解决这个问题查了很久，但是要么是介绍blueprint的，要么就是flask_restful插件入门，简直刺激\u0026hellip;\n","date":"2020-02-23T14:55:36Z","permalink":"https://blog.hunterji.com/p/flask_restful%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97%E5%8C%96/","title":"Flask_Restful视图函数模块化"},{"content":"url转为二维码 需要的库 qrcodejs2\n安装 1 npm install qrcodejs2 --save 引入 1 import QRCode from \u0026#34;qrcodejs2\u0026#34; 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div id=\u0026#34;qrcode\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import QRCode from \u0026#34;qrcodejs2\u0026#34;; export default { methods: { GenerateQRcode() { new QRCode(\u0026#34;qrcode\u0026#34;, { // 此处的qrcode为上面div的id text: 目标url, width: 200, height: 200, colorDark: \u0026#34;#000000\u0026#34;, colorLight: \u0026#34;#ffffff\u0026#34;, correctLevel: QRCode.CorrectLevel.H }); } }, mounted() { this.GenerateQRcode(); } } \u0026lt;/script\u0026gt; 网页保存为图片 需要的库 html2canvas\n安装 1 npm install html2canvas --save 引入 1 import html2canvas from \u0026#34;html2canvas\u0026#34; 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import html2canvas from \u0026#34;html2canvas\u0026#34;; import QRCode from \u0026#34;qrcodejs2\u0026#34;; export default { methods: { outputImg() { const targetDom = document.getElementById(\u0026#34;container\u0026#34;); html2canvas(targetDom).then(canvas =\u0026gt; { console.log(canvas); console.log(canvas.toDataURL()); }); } }, mounted() { this.outputImg(); } } \u0026lt;/script\u0026gt; 整合 关于小程序内置浏览器的图片下载，需要一个用来生成图片的块，还需要一个img，先将其隐藏。实现步骤就是首先生成二维码，然后再将html生成图片，最后在html2canvas回调中替换img的src，并将生成图片的块隐藏，将img显示。\n当然关于这个实现方式，我看到的技术分享文章中，还有两种不同的解决方式：\n不需要html来写生成图片的块，而是使用js直接创建； 不需要替换隐藏，将生成的图片覆盖到html生成图片的块之前； 这里我只记录一下我使用的，后期会再去研究这两种实现方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!--合成的图片，默认隐藏，合成之后显示--\u0026gt; \u0026lt;div v-show=\u0026#34;imgUrl.length\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;生成的图片\u0026#34; class=\u0026#34;image\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--合成图片需要的html块，默认显示，合成之后隐藏--\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34; v-show=\u0026#34;!imgUrl.length\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;qrcode\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;长按识别二维码\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import html2canvas from \u0026#34;html2canvas\u0026#34;; export default { data() { return { imgUrl: \u0026#34;\u0026#34; } }, methods: { outputImg() { const targetDom = document.getElementById(\u0026#34;container\u0026#34;); html2canvas(targetDom).then(canvas =\u0026gt; { // 将图片src替换为canvas生成之后转换的url this.imgUrl = canvas.toDataURL(); }); }, GenerateQRcode() { new QRCode(\u0026#34;qrcode\u0026#34;, { text: 目标url, width: 200, height: 200, colorDark: \u0026#34;#000000\u0026#34;, colorLight: \u0026#34;#ffffff\u0026#34;, correctLevel: QRCode.CorrectLevel.H }); } }, mounted() { new Promise(resolve =\u0026gt; { // 先生成二维码 this.GenerateQRcode(); resove(); }) .then(() =\u0026gt; { // 再合成图片 this.outputImg(); }) } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; // 生成之后的图片有点放肆，可以设置宽度来适应手机屏幕 .image { width: 100%; } \u0026lt;/style\u0026gt; 由此即可实现需要的功能了。\n关于后续的优化，需要解决的图片清晰度问题、跨域图片问题等，可以参考这篇文章，这位大佬写得很详细。\n","date":"2020-02-22T22:43:24Z","permalink":"https://blog.hunterji.com/p/vue2%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%92%8C%E5%B0%86%E7%BD%91%E9%A1%B5%E5%90%88%E6%88%90%E5%9B%BE%E7%89%87%E5%B9%B6%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%86%85%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E9%95%BF%E6%8C%89%E4%BF%9D%E5%AD%98/","title":"vue2实现实时生成二维码和将网页合成图片并在微信内置浏览器长按保存"}]